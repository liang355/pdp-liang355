<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Ifactor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment for class CS5010</a> &gt; <a href="index.source.html" class="el_package">org.nevec.rjm</a> &gt; <span class="el_source">Ifactor.java</span></div><h1>Ifactor.java</h1><pre class="source lang-java linenums">package org.nevec.rjm ;

import java.lang.* ;
import java.util.* ;
import java.math.* ;

/** Factored integers.
* This class contains a non-negative integer with the prime factor decomposition attached.
* @since 2006-08-14
* @since 2012-02-14 The internal representation contains the bases, and becomes sparser if few 
*    prime factors are present.
* @author Richard J. Mathar
*/
public class Ifactor implements Cloneable, Comparable&lt;Ifactor&gt;
{
        /**
        * The standard representation of the number
        */
        public BigInteger n ;

        /*
        * The bases and powers of the prime factorization.
        * representation n = primeexp[0]^primeexp[1]*primeexp[2]^primeexp[3]*...
        * The value 0 is represented by an empty vector, the value 1 by a vector of length 1
        * with a single power of 0.
        */
        public Vector&lt;Integer&gt; primeexp ;

<span class="nc" id="L29">        final public static Ifactor ONE = new Ifactor(1) ;</span>

<span class="nc" id="L31">        final public static Ifactor ZERO = new Ifactor(0) ;</span>

        /** Constructor given an integer.
        * constructor with an ordinary integer
        * @param number the standard representation of the integer
        */
        public Ifactor(int number)
<span class="nc" id="L38">        {</span>
<span class="nc" id="L39">                n = new BigInteger(&quot;&quot;+number) ;</span>
<span class="nc" id="L40">                primeexp = new Vector&lt;Integer&gt;() ;</span>
<span class="nc bnc" id="L41" title="All 2 branches missed.">                if( number &gt; 1 )</span>
                {
<span class="nc" id="L43">                        int primindx = 0 ;</span>
<span class="nc" id="L44">                        Prime primes = new Prime() ;</span>
                        /* Test division against all primes.
                        */
<span class="nc bnc" id="L47" title="All 2 branches missed.">                        while(number &gt; 1)</span>
                        {
<span class="nc" id="L49">                                int ex=0 ;</span>
                                /* primindx=0 refers to 2, =1 to 3, =2 to 5, =3 to 7 etc
                                */
<span class="nc" id="L52">                                int p = primes.at(primindx).intValue() ;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">                                while( number % p == 0 )</span>
                                {
<span class="nc" id="L55">                                        ex++ ;</span>
<span class="nc" id="L56">                                        number /= p ;</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">                                        if ( number == 1 )</span>
<span class="nc" id="L58">                                                break ;</span>
                                }
<span class="nc bnc" id="L60" title="All 2 branches missed.">                                if ( ex &gt; 0 )   </span>
                                {
<span class="nc" id="L62">                                        primeexp.add(new Integer(p)) ;</span>
<span class="nc" id="L63">                                        primeexp.add(new Integer(ex)) ;</span>
                                }
<span class="nc" id="L65">                                primindx++ ;</span>
<span class="nc" id="L66">                        }</span>
<span class="nc" id="L67">                }</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">                else if ( number == 1)</span>
                {
<span class="nc" id="L70">                        primeexp.add(new Integer(1)) ;</span>
<span class="nc" id="L71">                        primeexp.add(new Integer(0)) ;</span>
                }
<span class="nc" id="L73">        } /* Ifactor */</span>

        /** Constructor given a BigInteger .
        * Constructor with an ordinary integer, calling a prime factor decomposition.
        * @param number the BigInteger representation of the integer
        */
        public Ifactor(BigInteger number)
<span class="nc" id="L80">        {</span>
<span class="nc" id="L81">                n = number ;</span>
<span class="nc" id="L82">                primeexp = new Vector&lt;Integer&gt;() ;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">                if ( number.compareTo(BigInteger.ONE) == 0 )</span>
                {
<span class="nc" id="L85">                        primeexp.add(new Integer(1)) ;</span>
<span class="nc" id="L86">                        primeexp.add(new Integer(0)) ;</span>
                }
                else
                {
<span class="nc" id="L90">                        int primindx = 0 ;</span>
<span class="nc" id="L91">                        Prime primes = new Prime() ;</span>
                        /* Test for division against all primes.
                        */
<span class="nc bnc" id="L94" title="All 2 branches missed.">                        while(number.compareTo(BigInteger.ONE) == 1)</span>
                        {
<span class="nc" id="L96">                                int ex=0 ;</span>
<span class="nc" id="L97">                                BigInteger p = primes.at(primindx) ;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                                while( number.remainder(p).compareTo(BigInteger.ZERO) == 0 )</span>
                                {
<span class="nc" id="L100">                                        ex++ ;</span>
<span class="nc" id="L101">                                        number = number.divide(p) ;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                                        if ( number.compareTo(BigInteger.ONE) == 0 )</span>
<span class="nc" id="L103">                                                break ;</span>
                                }
<span class="nc bnc" id="L105" title="All 2 branches missed.">                                if ( ex &gt; 0 )</span>
                                {
<span class="nc" id="L107">                                        primeexp.add(new Integer(p.intValue()) ) ;</span>
<span class="nc" id="L108">                                        primeexp.add(new Integer(ex) ) ;</span>
                                }
<span class="nc" id="L110">                                primindx++ ;</span>
<span class="nc" id="L111">                        }</span>
                }
<span class="nc" id="L113">        } /* Ifactor */</span>

        /** Constructor given a list of exponents of the prime factor decomposition.
        * @param pows the vector with the sorted list of exponents.
        *  pows[0] is the exponent of 2, pows[1] the exponent of 3, pows[2] the exponent of 5 etc.
        *  Note that this list does not include the primes, but assumes a continuous prime-smooth basis.
        */
        public Ifactor(Vector&lt;Integer&gt; pows)
<span class="nc" id="L121">        {</span>
<span class="nc" id="L122">                primeexp = new Vector&lt;Integer&gt;(2* pows.size()) ;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if ( pows.size() &gt; 0 )</span>
                {
<span class="nc" id="L125">                        n = BigInteger.ONE ;</span>
<span class="nc" id="L126">                        Prime primes = new Prime() ;</span>
                        /* Build the full number by the product of all powers of the primes.
                        */
<span class="nc bnc" id="L129" title="All 2 branches missed.">                        for(int primindx=0 ; primindx &lt; pows.size() ; primindx++)</span>
                        {
<span class="nc" id="L131">                                int ex= pows.elementAt(primindx).intValue() ;</span>
<span class="nc" id="L132">                                final BigInteger p = primes.at(primindx) ;</span>
<span class="nc" id="L133">                                n = n.multiply( p.pow(ex) ) ;</span>
<span class="nc" id="L134">                                primeexp.add(new Integer(p.intValue()) ) ;</span>
<span class="nc" id="L135">                                primeexp.add(new Integer(ex) ) ;</span>
                        }
<span class="nc" id="L137">                }</span>
                else
<span class="nc" id="L139">                        n = BigInteger.ZERO ;</span>
<span class="nc" id="L140">        } /* Ifactor */</span>

        /** Copy constructor.
        * @param oth the value to be copied
        */
        public Ifactor(Ifactor oth)
<span class="nc" id="L146">        {</span>
<span class="nc" id="L147">                n = oth.n ;</span>
<span class="nc" id="L148">                primeexp = oth.primeexp ;</span>
<span class="nc" id="L149">        } /* Ifactor */</span>

        /** Deep copy.
        * @since 2009-08-14
        */
        public Ifactor clone()
        {
<span class="nc" id="L156">                Vector&lt;Integer&gt; p = (Vector&lt;Integer&gt;)primeexp.clone();</span>
<span class="nc" id="L157">                Ifactor cl = new Ifactor(0) ;</span>
<span class="nc" id="L158">                cl.n = new BigInteger(&quot;&quot;+n) ;</span>
<span class="nc" id="L159">                return cl ;</span>
        } /* Ifactor.clone */

        /** Comparison of two numbers.
        * The value of this method is in allowing the Vector&lt;&gt;.contains() calls that use the value,
        * not the reference for comparison.
        * @param oth the number to compare this with.
        * @return true if both are the same numbers, false otherwise.
        */
        public boolean equals(final Ifactor oth)
        {
<span class="nc bnc" id="L170" title="All 2 branches missed.">                return (  n.compareTo(oth.n) == 0 ) ;</span>
        } /* Ifactor.equals */

        /** Multiply with another positive integer.
        * @param oth the second factor.
        * @return the product of both numbers.
        */
        public Ifactor multiply(final BigInteger oth)
        {
                /* the optimization is to factorize oth _before_ multiplying
                */
<span class="nc" id="L181">                return( multiply(new Ifactor(oth)) ) ;</span>
        } /* Ifactor.multiply */

        /** Multiply with another positive integer.
        * @param oth the second factor.
        * @return the product of both numbers.
        */
        public Ifactor multiply(final int oth)
        {
                /* the optimization is to factorize oth _before_ multiplying
                */
<span class="nc" id="L192">                return( multiply(new Ifactor(oth)) ) ;</span>
        } /* Ifactor.multiply */

        /** Multiply with another positive integer.
        * @param oth the second factor.
        * @return the product of both numbers.
        */
        public Ifactor multiply(final Ifactor oth)
        {
                /* This might be done similar to the lcm() implementation by adding
                * the powers of the components and calling the constructor with the
                * list of exponents. This here is the simplest implementation, but slow because
                * it calls another prime factorization of the product:
                * return( new Ifactor(n.multiply(oth.n))) ;
                */
<span class="nc" id="L207">                return multGcdLcm(oth,0) ;</span>
        }

        /** Lowest common multiple of this with oth.
        * @param oth the second parameter of lcm(this,oth)
        * @return the lowest common multiple of both numbers. Returns zero
        *   if any of both arguments is zero.
        */
        public Ifactor lcm(final Ifactor oth)
        {
<span class="nc" id="L217">                return multGcdLcm(oth,2) ;</span>
        }

        /** Greatest common divisor of this and oth.
        * @param oth the second parameter of gcd(this,oth)
        * @return the lowest common multiple of both numbers. Returns zero
        *   if any of both arguments is zero.
        */
        public Ifactor gcd(final Ifactor oth)
        {
<span class="nc" id="L227">                return multGcdLcm(oth,1) ;</span>
        }

        /** Multiply with another positive integer.
        * @param oth the second factor.
        * @param type 0 to multiply, 1 for gcd, 2 for lcm
        * @return the product, gcd or lcm of both numbers.
        */
        protected Ifactor multGcdLcm(final Ifactor oth, int type)
        {
<span class="nc" id="L237">                Ifactor prod = new Ifactor(0) ;</span>
                /* skip the case where 0*something =0, falling thru to the empty representation for 0
                */
<span class="nc bnc" id="L240" title="All 4 branches missed.">                if( primeexp.size() != 0 &amp;&amp; oth.primeexp.size() != 0)</span>
                {
                        /* Cases of 1 times something return something.
                        * Cases of lcm(1, something) return something.
                        * Cases of gcd(1, something) return 1.
                        */
<span class="nc bnc" id="L246" title="All 4 branches missed.">                        if ( primeexp.firstElement().intValue() == 1 &amp;&amp; type == 0)</span>
<span class="nc" id="L247">                                return oth ;</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">                        else if ( primeexp.firstElement().intValue() == 1 &amp;&amp; type == 2)</span>
<span class="nc" id="L249">                                return oth ;</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">                        else if ( primeexp.firstElement().intValue() == 1 &amp;&amp; type == 1)</span>
<span class="nc" id="L251">                                return this ;</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">                        else if ( oth.primeexp.firstElement().intValue() == 1 &amp;&amp; type ==0)</span>
<span class="nc" id="L253">                                return this ;</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">                        else if ( oth.primeexp.firstElement().intValue() == 1 &amp;&amp; type ==2)</span>
<span class="nc" id="L255">                                return this ;</span>
<span class="nc bnc" id="L256" title="All 4 branches missed.">                        else if ( oth.primeexp.firstElement().intValue() == 1 &amp;&amp; type ==1)</span>
<span class="nc" id="L257">                                return oth ;</span>
                        else
                        {
<span class="nc" id="L260">                                int idxThis = 0 ;</span>
<span class="nc" id="L261">                                int idxOth = 0 ;</span>
<span class="nc bnc" id="L262" title="All 4 branches missed.">                                switch(type)</span>
                                {
                                case 0 :
<span class="nc" id="L265">                                        prod.n = n.multiply(oth.n) ;</span>
<span class="nc" id="L266">                                        break;</span>
                                case 1 :
<span class="nc" id="L268">                                        prod.n = n.gcd(oth.n) ;</span>
<span class="nc" id="L269">                                        break;</span>
                                case 2 :
                                        /* the awkward way, lcm = product divided by gcd
                                        */
<span class="nc" id="L273">                                        prod.n = n.multiply(oth.n).divide( n.gcd(oth.n) ) ;</span>
                                        break;
                                }

                                /* scan both representations left to right, increasing prime powers
                                */
<span class="nc bnc" id="L279" title="All 4 branches missed.">                                while( idxOth &lt; oth.primeexp.size()  || idxThis &lt; primeexp.size() )</span>
                                {
<span class="nc bnc" id="L281" title="All 2 branches missed.">                                        if ( idxOth &gt;= oth.primeexp.size() )</span>
                                        {
                                                /* exhausted the list in oth.primeexp; copy over the remaining 'this'
                                                * if multiplying or lcm, discard if gcd.
                                                */
<span class="nc bnc" id="L286" title="All 4 branches missed.">                                                if ( type == 0 || type == 2)</span>
                                                {
<span class="nc" id="L288">                                                        prod.primeexp.add( primeexp.elementAt(idxThis) ) ;</span>
<span class="nc" id="L289">                                                        prod.primeexp.add( primeexp.elementAt(idxThis+1) ) ;</span>
                                                }
<span class="nc" id="L291">                                                idxThis += 2 ;</span>
                                        }
<span class="nc bnc" id="L293" title="All 2 branches missed.">                                        else if ( idxThis &gt;= primeexp.size() )</span>
                                        {
                                                /* exhausted the list in primeexp; copy over the remaining 'oth'
                                                */
<span class="nc bnc" id="L297" title="All 4 branches missed.">                                                if ( type == 0 || type == 2)</span>
                                                {
<span class="nc" id="L299">                                                        prod.primeexp.add( oth.primeexp.elementAt(idxOth) ) ;</span>
<span class="nc" id="L300">                                                        prod.primeexp.add( oth.primeexp.elementAt(idxOth+1) ) ;</span>
                                                }
<span class="nc" id="L302">                                                idxOth += 2 ;</span>
                                        }
                                        else
                                        {
                                                Integer p ;
                                                int ex ;
<span class="nc bnc" id="L308" title="All 3 branches missed.">                                                switch ( primeexp.elementAt(idxThis).compareTo(oth.primeexp.elementAt(idxOth) ) )</span>
                                                {
                                                case 0 :
                                                        /* same prime bases p in both factors */
<span class="nc" id="L312">                                                        p = primeexp.elementAt(idxThis) ;</span>
<span class="nc bnc" id="L313" title="All 3 branches missed.">                                                        switch(type)</span>
                                                        {
                                                        case 0 :
                                                                /* product means adding exponents */
<span class="nc" id="L317">                                                                ex = primeexp.elementAt(idxThis+1).intValue() + </span>
<span class="nc" id="L318">                                                                        oth.primeexp.elementAt(idxOth+1).intValue() ;</span>
<span class="nc" id="L319">                                                                break;</span>
                                                        case 1 :
                                                                /* gcd means minimum of exponents */
<span class="nc" id="L322">                                                                ex = Math.min( primeexp.elementAt(idxThis+1).intValue() ,</span>
<span class="nc" id="L323">                                                                        oth.primeexp.elementAt(idxOth+1).intValue()) ;</span>
<span class="nc" id="L324">                                                                break;</span>
                                                        default :
                                                                /* lcm means maximum of exponents */
<span class="nc" id="L327">                                                                ex = Math.max( primeexp.elementAt(idxThis+1).intValue() ,</span>
<span class="nc" id="L328">                                                                        oth.primeexp.elementAt(idxOth+1).intValue()) ;</span>
                                                                break;
                                                        }
<span class="nc" id="L331">                                                        prod.primeexp.add( p ) ;</span>
<span class="nc" id="L332">                                                        prod.primeexp.add( new Integer(ex) ) ;</span>
<span class="nc" id="L333">                                                        idxOth += 2 ;</span>
<span class="nc" id="L334">                                                        idxThis += 2 ;</span>
<span class="nc" id="L335">                                                        break ;</span>
                                                case 1:
                                                        /* this prime base bigger than the other and taken later */
<span class="nc bnc" id="L338" title="All 4 branches missed.">                                                        if ( type == 0 || type == 2)</span>
                                                        {
<span class="nc" id="L340">                                                                prod.primeexp.add( oth.primeexp.elementAt(idxOth) ) ;</span>
<span class="nc" id="L341">                                                                prod.primeexp.add( oth.primeexp.elementAt(idxOth+1) ) ;</span>
                                                        }
<span class="nc" id="L343">                                                        idxOth += 2 ;</span>
<span class="nc" id="L344">                                                        break ;</span>
                                                default:
                                                        /* this prime base smaller than the other and taken now */
<span class="nc bnc" id="L347" title="All 4 branches missed.">                                                        if ( type == 0 || type == 2)</span>
                                                        {
<span class="nc" id="L349">                                                                prod.primeexp.add( primeexp.elementAt(idxThis) ) ;</span>
<span class="nc" id="L350">                                                                prod.primeexp.add( primeexp.elementAt(idxThis+1) ) ;</span>
                                                        }
<span class="nc" id="L352">                                                        idxThis += 2 ;</span>
                                                }
<span class="nc" id="L354">                                        }</span>
                                }
                        }
                }
<span class="nc" id="L358">                return prod ;</span>
        } /* Ifactor.multGcdLcm */

        /** Integer division through  another positive integer.
        * @param oth the denominator.
        * @return the division of this through the oth, discarding the remainder.
        */
        public Ifactor divide(final Ifactor oth)
        {
                /* todo: it'd probably be faster to cancel the gcd(this,oth) first in the prime power
                * representation, which would avoid a more strenous factorization of the integer ratio
                */
<span class="nc" id="L370">                return  new Ifactor(n.divide(oth.n)) ;</span>
        } /* Ifactor.divide */

        /** Summation with another positive integer
        * @param oth the other term.
        * @return the sum of both numbers
        */
        public Ifactor add(final BigInteger oth)
        {
                /* avoid refactorization if oth is zero...
                */
<span class="nc bnc" id="L381" title="All 2 branches missed.">                if ( oth.compareTo(BigInteger.ZERO) != 0 )</span>
<span class="nc" id="L382">                        return  new Ifactor(n.add(oth)) ;</span>
                else
<span class="nc" id="L384">                        return this ;</span>
        } /* Ifactor.add */

        /** Exponentiation with a positive integer.
        * @param exponent the non-negative exponent
        * @return n^exponent. If exponent=0, the result is 1.
        */
        public Ifactor pow(final int exponent) throws ArithmeticException
        {
                /* three simple cases first
                */
<span class="nc bnc" id="L395" title="All 2 branches missed.">                if ( exponent &lt; 0 )</span>
<span class="nc" id="L396">                        throw new ArithmeticException(&quot;Cannot raise &quot;+ toString() + &quot; to negative &quot; + exponent) ;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                else if ( exponent == 0)</span>
<span class="nc" id="L398">                        return new Ifactor(1) ;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                else if ( exponent == 1)</span>
<span class="nc" id="L400">                        return this ;</span>

                /* general case, the vector with the prime factor powers, which are component-wise
                * exponentiation of the individual prime factor powers.
                */
<span class="nc" id="L405">                Ifactor pows = new Ifactor(0) ;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                for(int i=0 ; i &lt; primeexp.size() ; i += 2)</span>
                {
<span class="nc" id="L408">                        Integer p = primeexp.elementAt(i) ;</span>
<span class="nc" id="L409">                        int ex = primeexp.elementAt(i+1).intValue() ;</span>
<span class="nc" id="L410">                        pows.primeexp.add( p ) ;</span>
<span class="nc" id="L411">                        pows.primeexp.add( new Integer(ex*exponent) ) ;</span>
                }
<span class="nc" id="L413">                return pows ;</span>
        } /* Ifactor.pow */

        /** Pulling the r-th root.
        * @param r the positive or negative (nonzero) root.
        * @return n^(1/r).
        *   The return value falls into the Ifactor class if r is positive, but if r is negative
        *   a Rational type is needed.
        * @since 2009-05-18
        */
        public Rational root(final int r) throws ArithmeticException
        {
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if ( r == 0 )</span>
<span class="nc" id="L426">                        throw new ArithmeticException(&quot;Cannot pull zeroth root of &quot;+ toString()) ;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">                else if ( r &lt; 0 )</span>
                {
                        /* a^(-1/b)= 1/(a^(1/b))
                        */
<span class="nc" id="L431">                        final Rational invRoot = root(-r) ;</span>
<span class="nc" id="L432">                        return Rational.ONE.divide(invRoot) ;</span>
                }
                else
                {
<span class="nc" id="L436">                        BigInteger pows = BigInteger.ONE ;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                        for(int i=0 ; i &lt; primeexp.size() ; i += 2)</span>
                        {
                                /* all exponents must be multiples of r to succeed (that is, to
                                * stay in the range of rational results).
                                */
<span class="nc" id="L442">                                int ex = primeexp.elementAt(i+1).intValue() ;</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                                if ( ex % r != 0 )</span>
<span class="nc" id="L444">                                        throw new ArithmeticException(&quot;Cannot pull &quot;+ r+&quot;th root of &quot;+ toString()) ;</span>

<span class="nc" id="L446">                                pows.multiply( new BigInteger(&quot;&quot;+primeexp.elementAt(i)).pow(ex/r) ) ;</span>
                        }
                        /* convert result to a Rational; unfortunately this will loose the prime factorization */
<span class="nc" id="L449">                        return new Rational(pows) ;</span>
                }
        } /* Ifactor.root */


        /** The set of positive divisors.
        * @return the vector of divisors of the absolute value, sorted.
        * @since 2010-08-27
        */
        public Vector&lt;BigInteger&gt; divisors()
        {
                /* Recursive approach: the divisors of p1^e1*p2^e2*..*py^ey*pz^ez are
                * the divisors that don't contain  the factor pz, and the
                * the divisors that contain any power of pz between 1 and up to ez multiplied
                * by 1 or by a product that contains the factors p1..py.
                */
<span class="nc" id="L465">                Vector&lt;BigInteger&gt; d=new Vector&lt;BigInteger&gt;() ;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if ( n.compareTo(BigInteger.ZERO) == 0 )</span>
<span class="nc" id="L467">                        return d ;</span>
<span class="nc" id="L468">                d.add(BigInteger.ONE) ;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">                if ( n.compareTo(BigInteger.ONE) &gt; 0 )</span>
                {
                        /* Computes sigmaIncopml(p1^e*p2^e2...*py^ey) */
<span class="nc" id="L472">                        Ifactor dp = dropPrime() ;</span>

                        /* get ez */
<span class="nc" id="L475">                        final int ez = primeexp.lastElement().intValue() ;</span>

<span class="nc" id="L477">                        Vector&lt;BigInteger&gt; partd = dp.divisors() ;</span>

                        /* obtain pz by lookup in the prime list */
<span class="nc" id="L480">                        final BigInteger pz = new BigInteger( primeexp.elementAt(primeexp.size()-2).toString()) ;</span>

                        /* the output contains all products of the form partd[]*pz^ez, ez&gt;0,
                        * and with the exception of the 1, all these are appended.
                        */
<span class="nc bnc" id="L485" title="All 2 branches missed.">                        for(int i =1 ; i &lt; partd.size() ; i++)</span>
<span class="nc" id="L486">                                d.add( partd.elementAt(i) ) ;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                        for(int e =1 ; e &lt;= ez ; e++)</span>
                        {
<span class="nc" id="L489">                                final BigInteger pzez = pz.pow(e) ;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                                for(int i =0 ; i &lt; partd.size() ; i++)</span>
<span class="nc" id="L491">                                        d.add( partd.elementAt(i).multiply(pzez) ) ;</span>
                        }
                }
<span class="nc" id="L494">                Collections.sort(d) ;</span>
<span class="nc" id="L495">                return d ;</span>
        } /* Ifactor.divisors */

        /** Sum of the divisors of the number.
        * @return the sum of all divisors of the number, 1+....+n.
        */
        public Ifactor sigma()
        {
<span class="nc" id="L503">                return sigma(1) ; </span>
        } /* Ifactor.sigma */

        /** Sum of the k-th powers of divisors of the number.
        * @return the sum of all divisors of the number, 1^k+....+n^k.
        */
        public Ifactor sigma(int k)
        {
                /* the question is whether keeping a factorization  is worth the effort
                * or whether one should simply multiply these to return a BigInteger...
                */
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if( n.compareTo(BigInteger.ONE) == 0 )</span>
<span class="nc" id="L515">                        return  ONE ;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                else if( n.compareTo(BigInteger.ZERO) == 0 )</span>
<span class="nc" id="L517">                        return  ZERO ;</span>
                else
                {
                        /* multiplicative: sigma_k(p^e) = [p^(k*(e+1))-1]/[p^k-1]
                        * sigma_0(p^e) = e+1.
                        */
<span class="nc" id="L523">                        Ifactor resul = Ifactor.ONE ;</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">                        for(int i=0 ; i &lt; primeexp.size() ; i += 2)</span>
                        {
<span class="nc" id="L526">                                int ex = primeexp.elementAt(i+1).intValue() ;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                                if ( k == 0 )</span>
<span class="nc" id="L528">                                        resul = resul.multiply(ex+1) ;</span>
                                else
                                {
<span class="nc" id="L531">                                        Integer p = primeexp.elementAt(i) ;</span>
<span class="nc" id="L532">                                        BigInteger num = (new BigInteger(p.toString())).pow(k*(ex+1)).subtract(BigInteger.ONE) ;</span>
<span class="nc" id="L533">                                        BigInteger deno = (new BigInteger(p.toString())).pow(k).subtract(BigInteger.ONE) ;</span>
                                        /* This division is of course exact, no remainder
                                        * The costly prime factorization is hidden here.
                                        */
<span class="nc" id="L537">                                        Ifactor f = new Ifactor(num.divide(deno)) ;</span>
<span class="nc" id="L538">                                        resul = resul.multiply(f) ;</span>
                                }
                        }
<span class="nc" id="L541">                        return resul ; </span>
                }
        } /* Ifactor.sigma */

        /** Divide through the highest possible power of the highest prime.
        * If the current number is the prime factor product p1^e1 * p2*e2* p3^e3*...*py^ey * pz^ez,
        * the value returned has the final factor pz^ez eliminated, which gives
        * p1^e1 * p2*e2* p3^e3*...*py^ey.
        * @return the new integer obtained by removing the highest prime power.
        *   If this here represents 0 or 1, it is returned without change.
        * @since 2006-08-20
        */
        public Ifactor dropPrime()
        {
                /* the cases n==1 or n ==0
                */
<span class="nc bnc" id="L557" title="All 2 branches missed.">                if ( n.compareTo(BigInteger.ONE) &lt;= 0 )</span>
<span class="nc" id="L558">                        return this ;</span>

                /* The cases n&gt;1
                * Start empty. Copy all but the last factor over to the result
                * the vector with the new prime factor powers, which contain the
                * old prime factor powers up to but not including the last one.
                */
<span class="nc" id="L565">                Ifactor pows=new Ifactor(0) ;</span>
<span class="nc" id="L566">                pows.n = BigInteger.ONE ;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                for(int i = 0 ; i &lt; primeexp.size()-2 ; i += 2)</span>
                {
<span class="nc" id="L569">                        pows.primeexp.add( primeexp.elementAt(i)) ;</span>
<span class="nc" id="L570">                        pows.primeexp.add( primeexp.elementAt(i+1)) ;</span>
<span class="nc" id="L571">                        BigInteger p = new BigInteger( primeexp.elementAt(i).toString() ) ;</span>
<span class="nc" id="L572">                        int ex = primeexp.elementAt(i+1).intValue() ;</span>
<span class="nc" id="L573">                        pows.n = pows.n.multiply( p.pow(ex) ) ;</span>
                }
<span class="nc" id="L575">                return pows ;</span>
        } /* Ifactor.dropPrime */

        /** Test whether this is a square of an integer (perfect square).
        * @return true if this is an integer squared (including 0), else false
        */
        public boolean issquare()
        {
<span class="nc" id="L583">                boolean resul= true ;</span>
                /* check the exponents, located at the odd-indexed positions
                */
<span class="nc bnc" id="L586" title="All 2 branches missed.">                for(int i=1 ; i &lt; primeexp.size() ; i += 2)</span>
                {
<span class="nc bnc" id="L588" title="All 2 branches missed.">                        if ( primeexp.elementAt(i).intValue() % 2 != 0)</span>
<span class="nc" id="L589">                                return false ;</span>
                }
<span class="nc" id="L591">                return true  ;</span>
        } /* Ifactor.issquare */

        /** The sum of the prime factor exponents, with multiplicity.
        * @return the sum over the primeexp numbers
        */
        public int bigomega()
        {
<span class="nc" id="L599">                int resul= 0 ;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                for(int i=1 ; i &lt; primeexp.size() ; i += 2)</span>
<span class="nc" id="L601">                        resul += primeexp.elementAt(i).intValue() ;</span>
<span class="nc" id="L602">                return(resul) ;</span>
        } /* Ifactor.bigomega */

        /** The sum of the prime factor exponents, without multiplicity.
        * @return the number of distinct prime factors.
        * @since 2008-10-16
        */
        public int omega()
        {
<span class="nc" id="L611">                return primeexp.size()/2 ;</span>
        } /* Ifactor.omega */

        /** The square-free part.
        * @return the minimum m such that m times this number is a square.
        * @since 2008-10-16
        */
        public BigInteger core()
        {
<span class="nc" id="L620">                BigInteger resul = BigInteger.ONE ;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                for(int i=0 ; i &lt; primeexp.size() ; i += 2)</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                        if ( primeexp.elementAt(i+1).intValue() % 2 != 0)</span>
<span class="nc" id="L623">                                resul = resul.multiply( new BigInteger(primeexp.elementAt(i).toString()) );</span>
<span class="nc" id="L624">                return resul ;</span>
        } /* Ifactor.core */

        /** The Moebius function.
        * 1 if n=1, else, if k is the number of distinct prime factors, return (-1)^k,
        * else, if k has repeated prime factors, return 0.
        * @return the moebius function.
        */
        public int moebius()
        {
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if( n.compareTo(BigInteger.ONE) &lt;= 0 )</span>
<span class="nc" id="L635">                        return 1 ;</span>
                /* accumulate number of different primes in k */
<span class="nc" id="L637">                int k=1 ;</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                for(int i=0 ; i &lt; primeexp.size() ; i += 2)</span>
                {
<span class="nc" id="L640">                        final int e = primeexp.elementAt(i+1).intValue() ;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">                        if ( e &gt; 1 )</span>
<span class="nc" id="L642">                                return 0 ;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                        else if ( e == 1)</span>
                                /* accumulates (-1)^k */
<span class="nc" id="L645">                                k *= -1 ;</span>
                        
                }
<span class="nc" id="L648">                return( k ) ;</span>
        } /* Ifactor.moebius */

        /** Maximum of two values.
        * @param oth the number to compare this with.
        * @return the larger of the two values.
        */
        public Ifactor max(final Ifactor oth)
        {
<span class="nc bnc" id="L657" title="All 2 branches missed.">                if( n.compareTo(oth.n) &gt;= 0 )</span>
<span class="nc" id="L658">                        return this ;</span>
                else
<span class="nc" id="L660">                        return oth  ;</span>
        } /* Ifactor.max */

        /** Minimum of two values.
        * @param oth the number to compare this with.
        * @return the smaller of the two values.
        */
        public Ifactor min(final Ifactor oth)
        {
<span class="nc bnc" id="L669" title="All 2 branches missed.">                if( n.compareTo(oth.n) &lt;= 0 )</span>
<span class="nc" id="L670">                        return this ;</span>
                else
<span class="nc" id="L672">                        return oth ;</span>
        } /* Ifactor.min */

        /** Maximum of a list of values.
        * @param set list of numbers.
        * @return the largest in the list.
        */
        public static Ifactor max(final Vector&lt;Ifactor&gt; set)
        {
<span class="nc" id="L681">                Ifactor resul = set.elementAt(0) ;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                for(int i=1; i &lt; set.size() ; i++)</span>
<span class="nc" id="L683">                        resul = resul.max(set.elementAt(i)) ;</span>
<span class="nc" id="L684">                return resul ;</span>
        } /* Ifactor.max */

        /** Minimum of a list of values.
        * @param set list of numbers.
        * @return the smallest in the list.
        */
        public static Ifactor min(final Vector&lt;Ifactor&gt; set)
        {
<span class="nc" id="L693">                Ifactor resul = set.elementAt(0) ;</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                for(int i=1; i &lt; set.size() ; i++)</span>
<span class="nc" id="L695">                        resul = resul.min(set.elementAt(i)) ;</span>
<span class="nc" id="L696">                return resul ;</span>
        } /* Ifactor.min */

        /** Compare value against another Ifactor
        * @param oth The value to be compared agains.
        * @return 1, 0 or -1 according to being larger, equal to or smaller than oth.
        * @since 2012-02-15
        */
        public int compareTo( final Ifactor oth)
        {
<span class="nc" id="L706">                return n.compareTo(oth.n) ;</span>
        } /* compareTo */

        /** Convert to printable format
        * @return a string of the form n:prime^pow*prime^pow*prime^pow...
        */
        public String toString()
        {
<span class="nc" id="L714">                String resul = new String(n.toString()+&quot;:&quot;) ;</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                if ( n.compareTo(BigInteger.ONE) == 0 )</span>
<span class="nc" id="L716">                        resul += &quot;1&quot; ;</span>
                else
                {
<span class="nc" id="L719">                        boolean firstMul = true ;</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">                        for(int i=0 ; i &lt; primeexp.size() ; i += 2)</span>
                        {
<span class="nc bnc" id="L722" title="All 2 branches missed.">                                if ( ! firstMul) </span>
<span class="nc" id="L723">                                        resul += &quot;*&quot; ;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">                                if ( primeexp.elementAt(i+1).intValue()  &gt; 1 )</span>
<span class="nc" id="L725">                                        resul += primeexp.elementAt(i).toString()+&quot;^&quot;+primeexp.elementAt(i+1).toString() ;</span>
                                else
<span class="nc" id="L727">                                        resul +=  primeexp.elementAt(i).toString() ;</span>
<span class="nc" id="L728">                                firstMul = false ;</span>
                        }
                }
<span class="nc" id="L731">                return resul ;</span>
        } /* Ifactor.toString */

        /** Test program.
        * It takes a single argument n and prints the integer factorizaton.&lt;br&gt;
        * java -cp . org.nevec.rjm.Ifactor n&lt;br&gt;
        */
        public static void main(String[] args) throws Exception
        {
<span class="nc" id="L740">                BigInteger n = new BigInteger(args[0]) ;</span>
<span class="nc" id="L741">                System.out.println( new Ifactor(n)) ;</span>
<span class="nc" id="L742">        } /* Ifactor.main */</span>
} /* Ifactor */
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>