<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Wigner3j.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment for class CS5010</a> &gt; <a href="index.source.html" class="el_package">org.nevec.rjm</a> &gt; <span class="el_source">Wigner3j.java</span></div><h1>Wigner3j.java</h1><pre class="source lang-java linenums">package org.nevec.rjm ;

import java.lang.* ;
import java.security.* ;
import java.util.* ;
import java.math.* ;


/** Exact representations of Wigner 3jm and 3nj values of half-integer arguments.
* @see R. J. Mathar, &lt;a href=&quot;http://arxiv.org/abs/1102.5125&quot;&gt;Corrigendum to &quot;Universal factorzation fo 3n-j (j&gt;2) symbols ..[J. Phys. A: Math. Gen.37 (2004) 3259]&quot;&lt;/a&gt;
* @see R. J. Mathar, &lt;a href=&quot;http://vixra.org/abs/1202.0093&quot;&gt;Symmetries in Wigner 18-j and 21-j Symbols&lt;/a&gt;
* @since 2011-02-15
* @author Richard J. Mathar
*/
<span class="nc" id="L15">public class Wigner3j</span>
{
        /** Test programs.
        * This supports three types of direct evaluations:&lt;br&gt;
        * java -cp . org.nevec.rjm.Wigner3j 3jm 2j1+1 2j2+1 2j3+1 2m1+1 2m2+1 2m3+1&lt;br&gt;
        * java -cp . org.nevec.rjm.Wigner3j 6j 2j1+1 2j2+2 .. 2j6+1&lt;br&gt;
        * java -cp . org.nevec.rjm.Wigner3j 9j 2j1+1 2j2+2 .. 2j9+1&lt;br&gt;
        * The first command line argument is one of the three tags which determine
        * whether a 3jm, a 6j or a 9j symbol will be computed. The other arguments are 6 or 9 integer
        * values, which are the physical (half-integer) values multplied by 2 and augmented by 1.
        * The order of the 6 or 9 values is as reading the corresponding standard symbol
        * as first row, then second row (and for the 9j symbol) third row.
        * @since 2011-02-15
        * @author Richard J. Mathar
        */
        static public void main(String args[])
        {
<span class="nc bnc" id="L32" title="All 2 branches missed.">                if ( args[0].compareTo(&quot;6j&quot;) == 0 )</span>
                {
                        try
                        {
<span class="nc" id="L36">                                String m1 = &quot;6&quot; ;</span>
<span class="nc" id="L37">                                String t1 = &quot;1 2 -3 -1 5 6&quot; ;</span>
<span class="nc" id="L38">                                String t2 = &quot;4 -5 3 -4 -2 -6&quot; ;</span>
<span class="nc" id="L39">                                String j = &quot;&quot; ;</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">                                for (int i=1; i &lt;= 6 ; i++)</span>
<span class="nc" id="L41">                                        j += args[i]+&quot; &quot; ;</span>
<span class="nc" id="L42">                                BigSurdVec w = wigner3j(m1,t1,t2,j) ;</span>
<span class="nc" id="L43">                                System.out.println(w.toString()) ;</span>
                        }
<span class="nc" id="L45">                        catch( Exception e)</span>
                        {
<span class="nc" id="L47">                                System.out.println(e.getMessage()) ;</span>
<span class="nc" id="L48">                        }</span>
                }
<span class="nc bnc" id="L50" title="All 2 branches missed.">                else if ( args[0].compareTo(&quot;9j&quot;) == 0 )</span>
                {
                        try
                        {
<span class="nc" id="L54">                                String m1 = &quot;9&quot; ;</span>
<span class="nc" id="L55">                                String t1 = &quot;1 3 2 4 6 5 7 9 8&quot; ;</span>
<span class="nc" id="L56">                                String t2 = &quot;2 8 5 6 3 9 7 4 1&quot; ;</span>
<span class="nc" id="L57">                                String j = &quot;&quot; ;</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">                                for (int i=1; i &lt;= 9 ; i++)</span>
<span class="nc" id="L59">                                        j += args[i]+&quot; &quot; ;</span>
<span class="nc" id="L60">                                BigSurdVec w = wigner3j(m1,t1,t2,j) ;</span>
<span class="nc" id="L61">                                System.out.println(w.toString()) ;</span>
                        }
<span class="nc" id="L63">                        catch( Exception e)</span>
                        {
<span class="nc" id="L65">                                System.out.println(e.getMessage()) ;</span>
<span class="nc" id="L66">                        }</span>
                }
<span class="nc bnc" id="L68" title="All 2 branches missed.">                else if ( args[0].compareTo(&quot;3jm&quot;) == 0 )</span>
                {
<span class="nc" id="L70">                        int j1 = (new Integer(args[1])).intValue() ;</span>
<span class="nc" id="L71">                        int j2 = (new Integer(args[2])).intValue() ;</span>
<span class="nc" id="L72">                        int j3 = (new Integer(args[3])).intValue() ;</span>
<span class="nc" id="L73">                        int m1 = (new Integer(args[4])).intValue() ;</span>
<span class="nc" id="L74">                        int m2 = (new Integer(args[5])).intValue() ;</span>
<span class="nc" id="L75">                        int m3 = (new Integer(args[6])).intValue() ;</span>
                        try
                        {
<span class="nc" id="L78">                                BigSurd w = wigner3jm(j1,j2,j3,m1,m2,m3) ;</span>
<span class="nc" id="L79">                                System.out.println(w.toString()) ;</span>
<span class="nc" id="L80">                                w =w.multiply(new BigSurd(j3+1,1)) ;</span>
<span class="nc" id="L81">                                System.out.println(&quot;CG factor sqrt&quot;+ (j3+1) + &quot;sign &quot; + ((j2-j2-m3)/2) + &quot; &quot; + w.toString() ) ;</span>
                        }
<span class="nc" id="L83">                        catch( Exception e)</span>
                        {
<span class="nc" id="L85">                                System.out.println(e.getMessage()) ;</span>
<span class="nc" id="L86">                        }</span>
<span class="nc" id="L87">                }</span>
                else
                {
<span class="nc" id="L90">                        System.out.println(&quot;usage:&quot;) ;</span>
<span class="nc" id="L91">                        System.out.println(args[0]+ &quot; 6j 2j1+1 2j2+1 2j3+1 2j4+1 2j5+1 2j6+1&quot;) ;</span>
<span class="nc" id="L92">                        System.out.println(args[0]+ &quot; 9j 2j1+1 2j2+1 2j3+1 2j4+1 2j5+1 2j6+1.. 2j9+1 &quot;) ;</span>
<span class="nc" id="L93">                        System.out.println(args[0]+ &quot; 3jm 2j1+1 2j2+1 2j3+1 2m1+1 2m2+1 2m3+1 &quot;) ;</span>
                }
<span class="nc" id="L95">        } /* Wigner3j.main */</span>


        /** The Wigner 3jm symbol (j1,j2,j3,m1,m2,m3).
        * All arguments of the function are the actual parameters multiplied by 2, so
        * they all allow an integer representation.
        * @param j1 integer representing 2*j1
        * @param j2 integer representing 2*j2
        * @param j3 integer representing 2*j3
        * @param m1 integer representing 2*m1
        * @param m2 integer representing 2*m2
        * @param m3 integer representing 2*m3
        * @return The value of the symbol. Zero if any of the triangular inequalities is
        *  violated or some parameters are out of range.
        * @since 2011-02-13
        * @author Richard J. Mathar
        */
        static public BigSurd wigner3jm(int j1, int j2, int j3, int m1, int m2, int m3)
        {
<span class="nc" id="L114">                Rational J1 = new Rational(j1,2) ;</span>
<span class="nc" id="L115">                Rational J2 = new Rational(j2,2) ;</span>
<span class="nc" id="L116">                Rational J3 = new Rational(j3,2) ;</span>
<span class="nc" id="L117">                Rational M1 = new Rational(m1,2) ;</span>
<span class="nc" id="L118">                Rational M2 = new Rational(m2,2) ;</span>
<span class="nc" id="L119">                Rational M3 = new Rational(m3,2) ;</span>
<span class="nc" id="L120">                return wigner3jm(J1,J2,J3,M1,M2,M3) ;</span>
        } /* wigner3jm */

        /** Wigner 3jn symbol.
        * For the 6j symbol, the input of the 3 lines is  &quot;1 2 3 1 5 6&quot;, &quot;4 5 3 4 2 6&quot; &quot;2j1+1 2j2+1 2j3+1 2l1+1 2l2+1 2l3+1&quot;
        * @param m1 The information on the number of angular momenta.
        * @param t1 The list of one half of the triads, indexing j, whitespace separated
        * @param t2 The list of the second half of the triads, indexing j, whitespace separated
        * @param j The list of the integer values of the angular momenta.
        *    They are actually the doubled j-values plus 1, whitespace separated. Only as many
        *    as announced by the m1 parameter are used; trailing numbers are ignored.
        * @see A. Bar-Shalom and M. Klapisch, &lt;a href=&quot;http://dx.doi.org/10.1016/0010-4655(88)90192-0&quot;&gt;NJGRAF...&lt;/a&gt;, Comp. Phys Comm. 50 (3) (1988) 375
        * @since 2011-02-13
        * @since 2012-02-15 Upgraded return value to BigSurdVec
        * @author Richard J. Mathar
        */
        static public BigSurdVec wigner3j(String m1, String t1, String t2, String j)
        {
                /* The first number in the line &quot;m&quot; is the number of angular momenta.
                * The rest of the line is ignored.
                */
<span class="nc" id="L141">                Scanner s = new Scanner(m1) ;</span>
<span class="nc" id="L142">                int m = s.nextInt() ;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                if ( m % 3 != 0 )</span>
<span class="nc" id="L144">                        throw new IllegalArgumentException(&quot;Angular momenta &quot;+m+&quot; not a multiple of three.&quot;) ;</span>

                /* Scan the numbers in the line &quot;j&quot;. Excess numbers beyond what
                * has been announced in the &quot;m&quot; line are ignored.
                */
<span class="nc" id="L149">                int[] jvec = new int [m] ;</span>
<span class="nc" id="L150">                int[] tvec = new int [2*m] ;</span>

                /* the third row contains positive 2j+1.
                */
<span class="nc" id="L154">                s = new Scanner(j) ;</span>
<span class="nc" id="L155">                int ji=0 ;</span>
<span class="nc bnc" id="L156" title="All 4 branches missed.">                while( s.hasNextInt() &amp;&amp; ji &lt; m)</span>
                {
<span class="nc" id="L158">                        jvec[ji++] = s.nextInt() ;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">                        if ( jvec[ji-1] &lt; 1 )</span>
<span class="nc" id="L160">                                throw new IllegalArgumentException(&quot;Illegal value &quot;+ jvec[ji-1] +&quot; for 2j+1.&quot;) ;</span>
                }

                /* the first two rows contain signed values of indices into the j list
                */
<span class="nc" id="L165">                s = new Scanner(t1) ;</span>
<span class="nc" id="L166">                int ti=0 ;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">                while( s.hasNextInt())</span>
<span class="nc" id="L168">                        tvec[ti++] = s.nextInt() ;</span>

<span class="nc" id="L170">                s = new Scanner(t2) ;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                while( s.hasNextInt())</span>
<span class="nc" id="L172">                        tvec[ti++] = s.nextInt() ;</span>

                /* Basic sanity checks. All indices in the first two lines address
                * a number in the third line, and each index occurs exactly twice.
                */
<span class="nc bnc" id="L177" title="All 2 branches missed.">                if ( ji % 3 != 0 )</span>
<span class="nc" id="L178">                        throw new IllegalArgumentException(&quot;j-count &quot;+ji+&quot; not a multiple of three.&quot;) ;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if ( ti != 2*ji )</span>
<span class="nc" id="L180">                        throw new IllegalArgumentException(&quot;triad-count &quot;+ti+&quot; not twice j-count &quot; + ji ) ;</span>

<span class="nc" id="L182">                int[] jfreq = new int[m] ;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                for(ji =0 ; ji &lt; jfreq.length ; ji++)</span>
<span class="nc" id="L184">                        jfreq[ji] = 0 ;</span>

                /* maintain a 0-based index which shows where the j-value
                * has its first and second occurrence in the flattened list of triads.
                */
<span class="nc" id="L189">                int[][] jhash = new int[m][2] ;</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">                for(ti =0 ; ti &lt; 2*m ; ti++)</span>
                {
<span class="nc" id="L193">                        int t = tvec[ti] ;</span>
<span class="nc bnc" id="L194" title="All 4 branches missed.">                        if ( t == 0 || Math.abs(t) &gt; jvec.length )</span>
<span class="nc" id="L195">                                throw new IllegalArgumentException(&quot;Triad index &quot;+t+&quot; out of bounds&quot;) ;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                        if ( jfreq[Math.abs(t)-1] &gt;= 2 )</span>
<span class="nc" id="L197">                                throw new IllegalArgumentException(&quot;Node &quot;+t+&quot; referenced more than twice&quot;) ;</span>
<span class="nc" id="L198">                        jhash[Math.abs(t)-1][jfreq[Math.abs(t)-1]] = ti ;</span>
<span class="nc" id="L199">                        jfreq[Math.abs(t)-1]++ ;</span>
                }

                /* Move on from the 2j+1 values of the input to the j-values.
                * Subtract one and divide through 2.
                */
<span class="nc" id="L205">                Rational [] J = new Rational[jvec.length] ;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">                for(ji=0 ; ji &lt; jvec.length ; ji ++)</span>
                {
<span class="nc" id="L208">                        J[ji] = new Rational(jvec[ji]-1,2) ;</span>
                }

                /* Convert the 1-based indices to 0-based indices, loosing the sign information.
                */
<span class="nc" id="L213">                int [] triadidx = new int[tvec.length] ;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                for(ti = 0 ; ti &lt; tvec.length; ti++)</span>
<span class="nc" id="L215">                        triadidx[ti] = Math.abs(tvec[ti])-1 ;</span>

                /* The M-values are all null (undetermined) at the start.
                */
<span class="nc" id="L219">                Rational [] M = new Rational[J.length] ;</span>

<span class="nc" id="L221">                return wigner3j(tvec,J,M,triadidx) ;</span>
        } /* wigner3j */

        /** Wigner 3jn symbol.
        * Computes sum_{mi} (-1)^(j1-m1+j2-m2+...) triad(triadidx[0..2])*triad(triadidx[3..5])*...
        * where each factor is a Wigner-3jm symbol with each sign of m_i occurring once at the
        * corresponding l-value.
        * @param triadidx 0-based indices into the list of J
        * @param J The list of J-values
        * @param M The list of M-values associated with the J. This contains null where the parameter has
        *   not yet been set by an outer loop.
        * @since 2011-02-13
        * @since 2012-02-15 Upgraded to return BigSurdVec
        * @author Richard J. Mathar
        */
        static private BigSurdVec wigner3j(final int[] tvec, final Rational[] J, final Rational[] M,final int[] triadidx)
        {
                /* The result of the computation. The sum over all m-combinations of the 
                * triads.
                */
<span class="nc" id="L241">                BigSurdVec res = new BigSurdVec() ;</span>

                /* First step is to monitor the triangular conditions on the J.
                * If at least one is violated, the result is zero. Loop over
                * the triads.
                */
<span class="nc bnc" id="L247" title="All 2 branches missed.">                for(int t=0 ; t &lt; triadidx.length ; t += 3)</span>
                {
                        /* Ensure |J[t]-J[t+1]| &lt;= J[t+2] &lt;= J[t]+J[t+1] */
<span class="nc bnc" id="L250" title="All 2 branches missed.">                        if ( J[triadidx[t]].subtract(J[triadidx[t+1]]).abs().compareTo( J[triadidx[t+2]]) &gt; 0 )</span>
<span class="nc" id="L251">                                return res ;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                        if ( J[triadidx[t]].add(J[triadidx[t+1]]).compareTo( J[triadidx[t+2]]) &lt; 0 )</span>
<span class="nc" id="L253">                                return res ;</span>
                }

                /* the index of the preferred member of the triad list.
                * Preference given to those dangling in triads where alreaday two others are fixed,
                * then to members where at least one is fixed, then to smallest associated J-values.
                */
<span class="nc" id="L260">                int freeM = -1 ;</span>
<span class="nc" id="L261">                int freeMrank = -1 ;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                for(int i=0 ; i &lt; triadidx.length ; i++)</span>
                {
                        /* found an m-value which has not yet been summed over.
                        */
<span class="nc bnc" id="L266" title="All 2 branches missed.">                        if ( M[triadidx[i]] == null)</span>
                        {
                                /* two cases: value is fixed implicitly because already two others values
                                * are set in the triad. or it is still to maintain its own explicit loop.
                                */
<span class="nc" id="L271">                                int triadn = i/3 ;</span>
<span class="nc" id="L272">                                int triadr = i%3 ;</span>
                                /* the neighbors in the triad have indices triadn*3+ (tiradr+1) mod 3 and triadn*3+(triadr+2) mod3
                                */
<span class="nc" id="L275">                                int nei1 = 3*triadn+(triadr+1)%3 ;</span>
<span class="nc" id="L276">                                int nei2 = 3*triadn+(triadr+2)%3 ;</span>

                                /* found a candidate for which the two other values are already set.
                                */
<span class="nc bnc" id="L280" title="All 4 branches missed.">                                if (M[triadidx[nei1]] != null &amp;&amp; M[triadidx[nei2]] != null)</span>
                                {
<span class="nc" id="L282">                                        freeM = i ;</span>
<span class="nc" id="L283">                                        break;</span>
                                }
                                else
                                {
                                        /* rough work load estimator: basically (2J1+1)*(2J2+1)
                                        */
<span class="nc" id="L289">                                        Rational wt = J[triadidx[i]].multiply(2).add(1) ;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                                        if (M[triadidx[nei1]] == null )</span>
<span class="nc" id="L291">                                                wt = wt.multiply( J[triadidx[nei1]].multiply(2).add(1) );</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                                        if (M[triadidx[nei2]] == null )</span>
<span class="nc" id="L293">                                                wt = wt.multiply( J[triadidx[nei2]].multiply(2).add(1) );</span>
<span class="nc" id="L294">                                        int thiswt = wt.intValue() ;</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">                                        if ( freeM &lt; 0 || thiswt &lt; freeMrank)</span>
                                        {
<span class="nc" id="L297">                                                freeM = i ;</span>
<span class="nc" id="L298">                                                freeMrank = thiswt ;</span>
                                        }
                                }
                        }
                }

<span class="nc bnc" id="L304" title="All 2 branches missed.">                if ( freeM &gt;= 0)</span>
                {
                        /* found an m-value which has not yet been summed over.
                        */
<span class="nc bnc" id="L308" title="All 2 branches missed.">                        if ( M[triadidx[freeM]] == null)</span>
                        {
<span class="nc" id="L310">                                Rational[] childM = new Rational[M.length] ;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                                for(int ji=0 ; ji&lt;M.length ; ji++)</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                                        if ( M[ji] != null)</span>
<span class="nc" id="L313">                                                childM[ji] = M[ji] ;</span>

                                /* two cases: value is fixed implicitly because already two others values
                                * are set in the triad. or it is still to maintain its own explicit loop.
                                */
<span class="nc" id="L318">                                int triadn = freeM/3 ;</span>
<span class="nc" id="L319">                                int triadr = freeM%3 ;</span>
                                /* the neighbors in the triad have indices triadn*3+ (triadr+1) mod 3 and triadn*3+(triadr+2) mod3
                                */
<span class="nc" id="L322">                                int nei1 = 3*triadn+(triadr+1)%3 ;</span>
<span class="nc" id="L323">                                int nei2 = 3*triadn+(triadr+2)%3 ;</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">                                if (M[triadidx[nei1]] == null || M[triadidx[nei2]] == null)</span>
                                {
                                        /* The J-value is J[triadidx[freeM]]. Loop from -J to +J, the allowed range.
                                        */
<span class="nc" id="L328">                                        Rational newm = J[triadidx[freeM]].negate() ;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">                                        while( newm.compareTo(J[triadidx[freeM]]) &lt;= 0 )        </span>
                                        {
<span class="nc bnc" id="L331" title="All 2 branches missed.">                                                childM[triadidx[freeM]] = tvec[freeM] &gt;0 ? newm : newm.negate() ;</span>
<span class="nc" id="L332">                                                res = res.add( wigner3j(tvec,J,childM,triadidx) ) ;</span>
<span class="nc" id="L333">                                                newm = newm.add(Rational.ONE) ;</span>
                                        }
<span class="nc" id="L335">                                }</span>
                                else
                                {
                                        /* Set its value and the value at its companion j-value.
                                        * Sum of the three m-values in the triad is to be zero for a non-zero contribution.
                                        */
<span class="nc" id="L341">                                        Rational m1 = M[triadidx[nei1]] ;</span>
<span class="nc" id="L342">                                        Rational m2 = M[triadidx[nei2]] ;</span>
                                        /* negate if these are the second occurrences of the J in the triads
                                        */
<span class="nc bnc" id="L345" title="All 2 branches missed.">                                        if ( tvec[nei1] &lt; 0)</span>
<span class="nc" id="L346">                                                m1 = m1.negate() ;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                                        if ( tvec[nei2] &lt; 0)</span>
<span class="nc" id="L348">                                                m2 = m2.negate() ;</span>
                                        /* m3 = -(m1+m2) */
<span class="nc bnc" id="L350" title="All 2 branches missed.">                                        Rational newm = tvec[freeM] &gt; 0 ? m1.add(m2).negate() :m1.add(m2) ;</span>
                                        /* No contribution if the m-value enforced by the other two entries
                                        * is outside the range -|J|..|J| enforced by its associated J-value. One could
                                        * essentially remove this branching and let wigner3j() decide on this,
                                        * but this is inefficient.
                                        */
<span class="nc bnc" id="L356" title="All 2 branches missed.">                                        if ( newm.abs().compareTo( J[triadidx[freeM]] ) &lt;= 0 )</span>
                                        {
<span class="nc" id="L358">                                                childM[triadidx[freeM]] = newm ;</span>
<span class="nc" id="L359">                                                res = res.add( wigner3j(tvec,J,childM,triadidx) ) ;</span>
                                        }
                                                /* zero contribution if this m-value cannot be set to any
                                                * value compatible with the triangular conditions.
                                                */
                                }
<span class="nc" id="L365">                                return res ;</span>
                        }
                }

                /* reached the bottom of the loop where all M-values are assigned.
                * Build the product over all Wigner-3jm values and the associated sign.
                */
<span class="nc" id="L372">                res = BigSurdVec.ONE ;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                for (int ji = 0 ; ji &lt; triadidx.length ; ji += 3)</span>
                {
<span class="nc" id="L375">                        Rational m1 = M[triadidx[ji]] ;</span>
<span class="nc" id="L376">                        Rational m2 = M[triadidx[ji+1]] ;</span>
<span class="nc" id="L377">                        Rational m3 = M[triadidx[ji+2]] ;</span>
                        /* negate if these are associated with in-flowing vectors in the triads
                        */
<span class="nc bnc" id="L380" title="All 2 branches missed.">                        if ( tvec[ji] &lt; 0)</span>
<span class="nc" id="L381">                                m1 = m1.negate() ;</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                        if ( tvec[ji+1] &lt; 0)</span>
<span class="nc" id="L383">                                m2 = m2.negate() ;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                        if ( tvec[ji+2] &lt; 0)</span>
<span class="nc" id="L385">                                m3 = m3.negate() ;</span>
<span class="nc" id="L386">                        res = res.multiply( wigner3jm( J[triadidx[ji]], J[triadidx[ji+1]], J[triadidx[ji+2]], m1,m2,m3 ) );</span>

                        /* if a partial product yields zero, the total product is zero, too, and
                        * offers an early exit.
                        */
<span class="nc bnc" id="L391" title="All 2 branches missed.">                        if ( res.signum() == 0 )</span>
<span class="nc" id="L392">                                return BigSurdVec.ZERO ;</span>
                }
                /* The overal sign is product_{J-Mpairs} (-1)^(J-M). This is an integer because all the J-M are integer.
                */
<span class="nc" id="L396">                Rational sig = new Rational() ;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                for(int ji=0 ; ji &lt; J.length ; ji++)</span>
<span class="nc" id="L398">                        sig = sig.add(J[ji]).subtract(M[ji]) ;</span>
                /* sign depends on the sum being even or odd. We assume that &quot;sig&quot; is integer and
                * look only at the numerator */
<span class="nc bnc" id="L401" title="All 2 branches missed.">                if ( sig.a.abs().testBit(0) )</span>
<span class="nc" id="L402">                        res = res.negate() ;</span>
<span class="nc" id="L403">                return res ;</span>
        } /* wigner3j */

        /** The Wigner 3jm symbol (j1,j2,j3,m1,m2,m3).
        * Warning: there is no check that each argument is indeed half-integer.
        * @param j1 integer or half-integer j1
        * @param j2 integer or half-integer j2
        * @param j3 integer or half-integer j3
        * @param m1 integer or half-integer m1
        * @param m2 integer or half-integer m2
        * @param m3 integer or half-integer m3
        * @return The value of the symbol. Zero if any of the triangular inequalities is
        *  violated or some parameters are out of range.
        * @since 2011-02-13
        * @author Richard J. Mathar
        */
        static protected BigSurd wigner3jm(Rational j1, Rational j2, Rational j3, Rational m1, Rational m2, Rational m3)
        {
                /* Check that m1+m2+m3 = 0 
                */
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if ( m1.add(m2).add(m3).signum() != 0 )</span>
<span class="nc" id="L424">                        return BigSurd.ZERO ;</span>

                /* Check that j1+j2+j3 is integer
                */
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if ( j1.add(j2).add(j3).isBigInteger() == false )</span>
<span class="nc" id="L429">                        return BigSurd.ZERO ;</span>

                /* Check that |j1-j2|&lt;=j3 &lt;= |j1+j2|
                */
<span class="nc" id="L433">                Rational j1m2 = j1.subtract(j2) ;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                if ( j1m2.abs().compareTo(j3) &gt; 0 )</span>
<span class="nc" id="L435">                        return BigSurd.ZERO ;</span>
<span class="nc" id="L436">                Rational j1p2 = j1.add(j2) ;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">                if ( j1p2.abs().compareTo(j3) &lt; 0 )</span>
<span class="nc" id="L438">                        return BigSurd.ZERO ;</span>

                /* Check that |m_i| &lt;= j_i
                */
<span class="nc bnc" id="L442" title="All 6 branches missed.">                if ( m1.abs().compareTo(j1) &gt; 0 || m2.abs().compareTo(j2) &gt; 0 || m3.abs().compareTo(j3) &gt; 0 )</span>
<span class="nc" id="L443">                        return BigSurd.ZERO ;</span>

                /* Check that m_i-j_i are integer.
                */
<span class="nc bnc" id="L447" title="All 6 branches missed.">                if ( ! m1.subtract(j1).isBigInteger() || ! m2.subtract(j2).isBigInteger() || ! m3.subtract(j3).isBigInteger() )</span>
<span class="nc" id="L448">                        return BigSurd.ZERO ;</span>

                /* (-)^(j1-j2-m3)*delta(-m3,m1+m2)*sqrt[ (j3+j1-j2)! (j3-j1+j2)! (j1+j2-j3)! /(j1+j2+j3+1)! 
                *                              *(j3-m)!*(j3+m)!(j1-m1)!*(j1+m1)!*(j2-m2)!*(j2+m2)!]
                *                               *sum_k (-1)^k/[k!(j1+j2-j3-k)!(j1-m1-k)!(j2+m2-k)!(j3-j2+m1+k)!)*(j3-j1-m2+k)!]
                */

                /* It is tacitly assumed that all the major j_i, m_i values are in the integer range.
                * This is implicitly plausible since otherwise the execution times of the following loop over the k-values
                * would be immense.     
                */
<span class="nc" id="L459">                int j1j2jk = j1p2.subtract(j3).intValue() ;</span>
<span class="nc" id="L460">                int j1m1k = j1.subtract(m1).intValue() ;</span>
<span class="nc" id="L461">                int j2m2k = j2.add(m2).intValue() ;</span>
<span class="nc" id="L462">                int jj2m1k = j3.subtract(j2).add(m1).intValue() ;</span>
<span class="nc" id="L463">                int jj1m2k = j3.subtract(j1).subtract(m2).intValue() ;</span>

<span class="nc" id="L465">                int k = Math.max(0,-jj2m1k) ;</span>
<span class="nc" id="L466">                k = Math.max(k,-jj1m2k) ;</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                if ( k &gt; 0 )</span>
                {
<span class="nc" id="L469">                        j1j2jk -= k ;</span>
<span class="nc" id="L470">                        j1m1k -= k ;</span>
<span class="nc" id="L471">                        j2m2k -= k ;</span>
<span class="nc" id="L472">                        jj2m1k += k ;</span>
<span class="nc" id="L473">                        jj1m2k += k ;</span>
                }

<span class="nc" id="L476">                Factorial f = new Factorial() ;</span>
<span class="nc" id="L477">                Rational sumk = new Rational() ;</span>
                while ( true)
                {
<span class="nc" id="L480">                        BigInteger d = f.at(k)</span>
<span class="nc" id="L481">                                .multiply(f.at(j1j2jk))</span>
<span class="nc" id="L482">                                .multiply(f.at(j1m1k))</span>
<span class="nc" id="L483">                                .multiply(f.at(j2m2k)) </span>
<span class="nc" id="L484">                                .multiply(f.at(jj2m1k))</span>
<span class="nc" id="L485">                                .multiply(f.at(jj1m2k)) ;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                        if ( k % 2 == 0)</span>
<span class="nc" id="L487">                                sumk = sumk.add(new Rational(BigInteger.ONE,d)) ;</span>
                        else
<span class="nc" id="L489">                                sumk = sumk.subtract(new Rational(BigInteger.ONE,d)) ;</span>
<span class="nc" id="L490">                        j1j2jk-- ;</span>
<span class="nc" id="L491">                        j1m1k-- ;</span>
<span class="nc" id="L492">                        j2m2k-- ;</span>
<span class="nc" id="L493">                        jj2m1k++ ;</span>
<span class="nc" id="L494">                        jj1m2k++ ;</span>
<span class="nc bnc" id="L495" title="All 6 branches missed.">                        if ( j1j2jk &lt;0 || j1m1k &lt; 0 || j2m2k &lt; 0 )</span>
<span class="nc" id="L496">                                break;</span>
<span class="nc" id="L497">                        k++ ;</span>
<span class="nc" id="L498">                }</span>
                /* sign factor (-1)^(j1-j2-m3)
                */
<span class="nc bnc" id="L501" title="All 2 branches missed.">                if ( j1m2.subtract(m3).intValue() %2 != 0 )</span>
<span class="nc" id="L502">                        sumk = sumk.negate() ;</span>

<span class="nc" id="L504">                k = j1m2.add(j3).intValue() ;</span>
<span class="nc" id="L505">                BigInteger s = f.at(k) ;</span>
<span class="nc" id="L506">                k = j3.subtract(j1m2).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L507">                k = j1p2.subtract(j3).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L508">                k = j3.add(m3).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L509">                k = j3.subtract(m3).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L510">                k = j1.add(m1).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L511">                k = j1.subtract(m1).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L512">                k = j2.add(m2).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L513">                k = j2.subtract(m2).intValue() ; s = s.multiply(f.at(k)) ;</span>
<span class="nc" id="L514">                k = j1p2.add(j3).intValue() ; k++ ;</span>
<span class="nc" id="L515">                Rational disc = new Rational( s, f.at(k) ) ;</span>
<span class="nc" id="L516">                return new BigSurd(sumk,disc) ;</span>
        } /* wigner3jm */


} /* Wigner3j */
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>