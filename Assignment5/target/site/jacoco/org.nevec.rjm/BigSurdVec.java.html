<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BigSurdVec.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment for class CS5010</a> &gt; <a href="index.source.html" class="el_package">org.nevec.rjm</a> &gt; <span class="el_source">BigSurdVec.java</span></div><h1>BigSurdVec.java</h1><pre class="source lang-java linenums">package org.nevec.rjm ;

import java.util.* ;
import java.security.* ;
import java.math.* ;

/** A BigSurdVec represents an algebraic sum or differences of values
* which each term an instance of BigSurd.
* This mainly means that sums or differences of two BigSurd (or two BigSurdVec) can
* be represented (exactly) as a BigSurdVec.
* @since 2012-02-15
* @author Richard J. Mathar
*/
public class BigSurdVec implements Comparable&lt;BigSurdVec&gt;
{
        /** The value of zero.
        */
<span class="nc" id="L18">        static public BigSurdVec ZERO = new BigSurdVec() ;</span>

        /** The value of one.
        */
<span class="nc" id="L22">        static public BigSurdVec ONE = new BigSurdVec(BigSurd.ONE) ;</span>

        /** Internal representation: Each term as a single BigSurd.
        * The value zero is represented by an empty vector.
        */
        Vector&lt;BigSurd&gt; terms ;

        /** Default ctor, which represents the zero.
        * @since 2012-02-15
        */
        public BigSurdVec()
<span class="nc" id="L33">        {</span>
<span class="nc" id="L34">                terms = new Vector&lt;BigSurd&gt;() ;</span>
<span class="nc" id="L35">        } /* ctor */</span>

        /** ctor given the value of a BigSurd.
        * @param a The value to be represented by this vector.
        * @since 2012-02-15
        */
        public BigSurdVec(BigSurd a)
<span class="nc" id="L42">        {</span>
<span class="nc" id="L43">                terms = new Vector&lt;BigSurd&gt;(1) ;</span>
<span class="nc" id="L44">                terms.add(a) ;</span>
<span class="nc" id="L45">        } /* ctor */</span>

        /** ctor given two values, which (when added) represent this number a+b.
        * @param a The value to be represented by the first term of the vector.
        * @param b The value to be represented by the second term of the vector.
        * @since 2012-02-15
        */
        public BigSurdVec(BigSurd a, BigSurd b)
<span class="nc" id="L53">        {</span>
<span class="nc" id="L54">                terms = new Vector&lt;BigSurd&gt;(2) ;</span>
<span class="nc" id="L55">                terms.add(a) ;</span>
<span class="nc" id="L56">                terms.add(b) ;</span>
<span class="nc" id="L57">                normalize() ;</span>
<span class="nc" id="L58">        } /* ctor */</span>

        /** Combine terms that can be written as a single surd.
        * This unites for example the terms sqrt(90) and sqrt(10) to 4*sqrt(10).
        * @since 2012-02-15
        */
        protected void normalize()
        {
                /* nothing to be done if at most one term
                */
<span class="nc bnc" id="L68" title="All 2 branches missed.">                if ( terms.size() &lt;=1 )</span>
<span class="nc" id="L69">                        return ;</span>

<span class="nc" id="L71">                Vector&lt;BigSurd&gt; newter = new Vector&lt;BigSurd&gt;() ;</span>
<span class="nc" id="L72">                newter.add( terms.firstElement()) ;</span>
                /* add j-th element to the existing vector and combine were possible
                */
<span class="nc bnc" id="L75" title="All 2 branches missed.">                for(int j=1 ; j &lt; terms.size() ; j++)</span>
                {
<span class="nc" id="L77">                        BigSurd todo = terms.elementAt(j) ;</span>
<span class="nc" id="L78">                        boolean merged = false ;</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                        for(int ex=0 ; ex &lt; newter.size() ; ex++)</span>
                        {
<span class="nc" id="L81">                                BigSurd v = newter.elementAt(ex) ;</span>
                                /* try to merge terms[j] and newter[ex].
                                * todo = r * v with r a rational number is needed. 
                                * Replaces v with v+todo = v*(1+r) if this reduction works.
                                */
<span class="nc" id="L86">                                BigSurd r = todo.divide(v) ;</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                                if ( r.isRational() )</span>
                                {
                                        /* compute r+1 */
<span class="nc" id="L90">                                        Rational newpref = r.toRational().add(1) ;</span>
                                        /* eliminate accidental zeros; overwrite with v*(1+r).
                                        */
<span class="nc bnc" id="L93" title="All 2 branches missed.">                                        if ( newpref.compareTo( Rational.ZERO) == 0 )</span>
<span class="nc" id="L94">                                                newter.removeElementAt(ex) ;</span>
                                        else
                                        {
<span class="nc" id="L97">                                                v = v.multiply(newpref) ;</span>
<span class="nc" id="L98">                                                newter.setElementAt(v,ex) ;</span>
                                        }
<span class="nc" id="L100">                                        merged =true;</span>
<span class="nc" id="L101">                                        break ;</span>
                                }
                        }
                        /* append if none of the existing elements matched
                        */
<span class="nc bnc" id="L106" title="All 2 branches missed.">                        if ( ! merged)</span>
<span class="nc" id="L107">                                newter.add(todo) ;</span>
                }

                /* overwrite old version */
<span class="nc" id="L111">                terms = newter ;</span>
<span class="nc" id="L112">        } /* normalize */</span>
                
        /** Compare algebraic value with oth.
        * Returns -1, 0 or +1 depending on whether this is smaller, equal to or larger than oth.
        * @param oth The value with which this is to be compared.
        * @return 0 or +-1.
        * @since 2012-02-15
        */
        public int compareTo(BigSurdVec oth)
        {
<span class="nc" id="L122">                final BigSurdVec diff = this.subtract(oth) ;</span>
<span class="nc" id="L123">                return diff.signum() ;</span>
        } /* compareTo */
        
        /** Sign function.
        * Returns -1, 0 or +1 depending on whether this is smaller, equal to or larger than zero.
        * @return 0 or +-1.
        * @since 2012-02-15
        */
        public int signum()
        {
                /* the case of zero is unique, because no (reduced) vector of surds other than
                * the one element 0 itself can add/subtract to zero.
                */
<span class="nc bnc" id="L136" title="All 2 branches missed.">                if ( terms.size() == 0 )</span>
<span class="nc" id="L137">                        return 0 ;</span>

                /* if there is one term: forward to the signum function of BigSurd
                */
<span class="nc bnc" id="L141" title="All 2 branches missed.">                if ( terms.size() == 1 )</span>
<span class="nc" id="L142">                        return terms.firstElement().signum() ;</span>

                /* if all terms have a common sign: take that one
                * offsig is the index of the first &quot;offending&quot; term in the sense that its
                * sign doese not agree with the term[0].
                */
<span class="nc" id="L148">                int sig0 = terms.elementAt(0).signum() ;</span>
<span class="nc" id="L149">                int offsig = 1;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                for( ; offsig &lt; terms.size() ; offsig++)</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                        if ( terms.elementAt(offsig).signum() != sig0)</span>
<span class="nc" id="L152">                                break;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                if ( offsig &gt;= terms.size() )</span>
<span class="nc" id="L154">                        return sig0 ;</span>

                /* if there are two terms (now known to have different sign):
                * forward to the comparison of the two elements as BigSurds
                */
<span class="nc bnc" id="L159" title="All 2 branches missed.">                if ( terms.size() == 2 )</span>
<span class="nc" id="L160">                        return terms.elementAt(0).compareTo( terms.elementAt(1).negate() ) ;</span>

                /* if there are three terms, move the one with the offending sign to the
                * other side and square both sides (which looses the sign) to remove all but one surds.
                * The difference of the squared sides contains at most two terms, which reduces to the
                * case above.
                *  t(0)+t(offbar) &lt;&gt; -t(offs)
                */
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if ( terms.size() == 3 )</span>
                {
                        BigSurdVec lhs ;
<span class="nc bnc" id="L171" title="All 2 branches missed.">                        if ( offsig == 2)</span>
<span class="nc" id="L172">                                lhs = new BigSurdVec( terms.elementAt(0), terms.elementAt(1)) ;</span>
                        else
<span class="nc" id="L174">                                lhs = new BigSurdVec( terms.elementAt(0), terms.elementAt(2)) ;</span>
<span class="nc" id="L175">                        lhs = lhs.sqr() ;</span>
<span class="nc" id="L176">                        BigSurd rhs = new BigSurd(terms.elementAt(offsig).sqr(),Rational.ONE) ;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                        if ( lhs.compareTo(lhs) &gt; 0 )</span>
                                /* dominating sign was t(0)+t(offbar)
                                */
<span class="nc" id="L180">                                return terms.elementAt(0).signum() ;</span>
                        else
<span class="nc" id="L182">                                return terms.elementAt(offsig).signum() ;</span>
                }

                /* for a larger number of terms: take a floating point representation with a small
                * but correct number of digits, and resume with the sign of that one.
                */
<span class="nc bnc" id="L188" title="All 2 branches missed.">                return (floatValue() &gt; 0. ) ? 1 : -1 ;</span>

        } /* signum */

        /** Construct an approximate floating point representation
        * @param mc The intended accuracy of the result.
        * @return A truncated version with the precision described by mc
        */
        public BigDecimal BigDecimalValue(MathContext mc)
        {
                /* simple cases with one term forwarded to the BigSurd class
                */
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if ( terms.size() == 0 )</span>
<span class="nc" id="L201">                        return BigDecimal.ZERO ;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                else if ( terms.size() == 1 )</span>
                {
<span class="nc" id="L204">                        return terms.firstElement().BigDecimalValue(mc) ;</span>
                }

                /* To reduce cancellation errors, loop over increasing local precision
                * until we are stable to the required result. Keep the old (less precise)
                * estimate in res[0], and the newer, more precise in res[1].
                */
<span class="nc" id="L211">                BigDecimal [] res = new BigDecimal[2] ;</span>
<span class="nc" id="L212">                res[0] = BigDecimal.ZERO ;</span>
<span class="nc" id="L213">                for(int addpr =1 ; ; addpr += 3)</span>
                {
<span class="nc" id="L215">                        MathContext locmc = new MathContext(mc.getPrecision()+addpr,mc.getRoundingMode()) ;</span>
<span class="nc" id="L216">                        res[1] = BigDecimal.ZERO ;</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">                        for( BigSurd j : terms)</span>
<span class="nc" id="L218">                                res[1] = BigDecimalMath.addRound(res[1], j.BigDecimalValue(locmc) ) ;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                        if ( addpr &gt; 1 )</span>
                        {
<span class="nc" id="L221">                                BigDecimal err = res[1].subtract(res[0]).abs() ;</span>
<span class="nc" id="L222">                                int prec = BigDecimalMath.err2prec(res[1],err) ;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">                                if ( prec &gt; mc.getPrecision() )</span>
<span class="nc" id="L224">                                        break ;</span>
                        }
<span class="nc" id="L226">                        res[0] = res[1] ;</span>
                }
<span class="nc" id="L228">                return BigDecimalMath.scalePrec(res[1],mc) ;</span>
        
        } /* BigDecimalValue */

        /** Construct an approximate floating point representation
        * @return A truncated version with the precision described by mc
        */
        public double doubleValue()
        {
<span class="nc" id="L237">                BigDecimal bd = BigDecimalValue(MathContext.DECIMAL128) ;</span>
<span class="nc" id="L238">                return bd.doubleValue() ;</span>
        } /* doubleValue */

        /** Construct an approximate floating point representation
        * @return A truncated version with the precision described by mc
        */
        public double floatValue()
        {
<span class="nc" id="L246">                BigDecimal bd = BigDecimalValue(MathContext.DECIMAL64) ;</span>
<span class="nc" id="L247">                return bd.floatValue() ;</span>
        } /* floatValue */

        /** Add two vectors algebraically.
        * @param val The value to be added to this.
        * @return The new value representing this+val.
        */
        public BigSurdVec add(final BigSurdVec val)
        {
<span class="nc" id="L256">                BigSurdVec sum = new BigSurdVec() ;</span>
                /* concatenate the vectors and eliminate common overlaps
                */
<span class="nc" id="L259">                sum.terms.addAll( terms) ;</span>
<span class="nc" id="L260">                sum.terms.addAll( val.terms) ;</span>
<span class="nc" id="L261">                sum.normalize() ;</span>
<span class="nc" id="L262">                return sum ;</span>
        } /* add */

        /** Add two vectors algebraically.
        * @param val The value to be added to this.
        * @return The new value representing this+val.
        */
        public BigSurdVec add(final BigSurd val)
        {
<span class="nc" id="L271">                BigSurdVec sum = new BigSurdVec() ;</span>
                /* concatenate the vectors and eliminate common overlaps
                */
<span class="nc" id="L274">                sum.terms.addAll( terms) ;</span>
<span class="nc" id="L275">                sum.terms.add( val) ;</span>
<span class="nc" id="L276">                sum.normalize() ;</span>
<span class="nc" id="L277">                return sum ;</span>
        } /* add */

        /** Subtract another number.
        * @param val The value to be subtracted from this.
        * @return The new value representing this-val.
        */
        public BigSurdVec subtract(final BigSurdVec val)
        {
<span class="nc" id="L286">                BigSurdVec sum = new BigSurdVec() ;</span>
                /* concatenate the vectors and eliminate common overlaps
                */
<span class="nc" id="L289">                sum.terms.addAll( terms) ;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                for ( BigSurd s : val.terms)</span>
<span class="nc" id="L291">                        sum.terms.add( s.negate() ) ;</span>
<span class="nc" id="L292">                sum.normalize() ;</span>
<span class="nc" id="L293">                return sum ;</span>
        } /* subtract */

        /** Subtract another number.
        * @param val The value to be subtracted from this.
        * @return The new value representing this-val.
        */
        public BigSurdVec subtract(final BigSurd val)
        {
<span class="nc" id="L302">                BigSurdVec sum = new BigSurdVec() ;</span>
                /* concatenate the vectors and eliminate common overlaps
                */
<span class="nc" id="L305">                sum.terms.addAll( terms) ;</span>
<span class="nc" id="L306">                sum.terms.add( val.negate() ) ;</span>
<span class="nc" id="L307">                sum.normalize() ;</span>
<span class="nc" id="L308">                return sum ;</span>
        } /* subtract */

        /** Compute the negative.
        * @return -this.
        * @since 2012-02-15
        */
        public BigSurdVec negate()
        {
                /* accumulate the negated elements of term one by one
                */
<span class="nc" id="L319">                BigSurdVec resul = new BigSurdVec() ;</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                for( BigSurd s : terms)</span>
<span class="nc" id="L321">                        resul.terms.add( s.negate()) ;</span>
                /* no normalization step here, because the negation of all terms
                * does not introduce new common factors
                */
<span class="nc" id="L325">                return resul ;</span>
        } /* negate */

        /** Compute the square.
        * @return this value squared.
        * @since 2012-02-15
        */
        public BigSurdVec sqr()
        {
                /* Binomial expansion. First the sum of the terms squared,
                * then 2 times the mixed products.
                */
<span class="nc" id="L337">                BigSurdVec resul = new BigSurdVec() ;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                for( int i=0 ; i &lt; terms.size() ; i++)</span>
<span class="nc" id="L339">                        resul.terms.add( new BigSurd(terms.elementAt(i).sqr(),Rational.ONE) ) ;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                for( int i=0 ; i &lt; terms.size()-1 ; i++)</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                for( int j= i+1 ; j &lt; terms.size() ; j++)</span>
<span class="nc" id="L342">                        resul.terms.add( terms.elementAt(i).multiply(terms.elementAt(j)).multiply(2) ) ;</span>
<span class="nc" id="L343">                resul.normalize() ;</span>
<span class="nc" id="L344">                return resul ;</span>
        } /* sqr */

        /** Multiply by another square root.
        * @param val a second number of this type.
        * @return the product of this with the val.
        * @since 2011-02-12
        */
        public BigSurdVec multiply(final BigSurd val)
        {
<span class="nc" id="L354">                BigSurdVec resul = new BigSurdVec() ;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                for( BigSurd s : terms)</span>
<span class="nc" id="L356">                        resul.terms.add( s.multiply(val) )  ;</span>
<span class="nc" id="L357">                resul.normalize() ;</span>
<span class="nc" id="L358">                return resul ;</span>
        } /* multiply */

        /** Return a string in the format (number/denom)*()^(1/2).
        * If the discriminant equals 1, print just the prefactor.
        * @return the human-readable version in base 10
        * @since 2012-02-16
        */
        public String toString()
        {
                /* simple cases with one term forwarded to the BigSurd class
                */
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if ( terms.size() == 0 )</span>
<span class="nc" id="L371">                        return new String(&quot;0&quot;) ;</span>
                else 
                {
<span class="nc" id="L374">                        String s = new String() ;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                        for(int t=0 ; t&lt; terms.size() ; t++)</span>
                        {
<span class="nc" id="L377">                                BigSurd bs = terms.elementAt(t) ;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                                if ( bs.signum() &gt; 0 )</span>
<span class="nc" id="L379">                                        s += &quot;+&quot; ;</span>
<span class="nc" id="L380">                                s += bs.toString() ;</span>
                        }
<span class="nc" id="L382">                        return s ;</span>
                }
        } /* toString */




} /* BigSurdVec */
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>