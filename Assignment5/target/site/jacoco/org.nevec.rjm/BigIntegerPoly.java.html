<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BigIntegerPoly.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment for class CS5010</a> &gt; <a href="index.source.html" class="el_package">org.nevec.rjm</a> &gt; <span class="el_source">BigIntegerPoly.java</span></div><h1>BigIntegerPoly.java</h1><pre class="source lang-java linenums">package org.nevec.rjm ;

import java.lang.* ;
import java.security.* ;
import java.util.* ;
import java.math.* ;

/** Polynomial with integer coefficients.
* Alternatively to be interpreted as a sequence which has the polynomial as an (approximate)
* generating function.
* @since 2010-08-27
* @author Richard J. Mathar
*/
public class BigIntegerPoly implements Cloneable
{
        /** The list of all coefficients, starting with a0, then a1, as in
        * poly=a0+a1*x+a2*x^2+a3*x^3+...
        */
        Vector&lt;BigInteger&gt; a ;

        /** Default ctor.
        * Creates the polynomial p(x)=0.
        */
        public BigIntegerPoly()
<span class="nc" id="L25">        {</span>
<span class="nc" id="L26">                a = new Vector&lt;BigInteger&gt;() ;</span>
<span class="nc" id="L27">        }</span>

        /** Ctor with a comma-separated list as the list of coefficients.
        * @param L the string of the form a0,a1,a2,a3 with the coefficients
        */
        public BigIntegerPoly(final String L) throws NumberFormatException
<span class="nc" id="L33">        {</span>
<span class="nc" id="L34">                a = new Vector&lt;BigInteger&gt;() ;</span>
<span class="nc" id="L35">                Scanner sc = new Scanner(L) ;</span>
<span class="nc" id="L36">                sc.useDelimiter(&quot;,&quot;) ;</span>
<span class="nc bnc" id="L37" title="All 2 branches missed.">                while ( sc.hasNextBigInteger())</span>
<span class="nc" id="L38">                        a.add(sc.nextBigInteger()) ;</span>
<span class="nc" id="L39">                simplify() ;</span>
<span class="nc" id="L40">        } /* ctor */</span>

        /** Ctor with a list of coefficients.
        * @param c The coefficients a0, a1, a2 etc in a0+a1*x+a2*x^2+...
        */
        public BigIntegerPoly(final Vector&lt;BigInteger&gt; c)
<span class="nc" id="L46">        {</span>
<span class="nc" id="L47">                a = (Vector&lt;BigInteger&gt;)c.clone() ;</span>
<span class="nc" id="L48">                simplify() ;</span>
<span class="nc" id="L49">        } /* ctor */</span>

        /** Ctor with a list of coefficients.
        * @param c The coefficients a0, a1, a2 etc in a0+a1*x+a2*x^2+...
        */
        public BigIntegerPoly(final BigInteger[] c)
<span class="nc" id="L55">        {</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">                for(int i=0 ; i &lt; c.length; i++)</span>
<span class="nc" id="L57">                        a.add( c[i].add(BigInteger.ZERO) ) ;</span>
<span class="nc" id="L58">                simplify() ;</span>
<span class="nc" id="L59">        } /* ctor */</span>

        /** Create a copy of this.
        * @since 2010-08-27
        */
        public BigIntegerPoly clone()
        {
<span class="nc" id="L66">                return new BigIntegerPoly(a) ;</span>
        } /* clone */


        /** Translate into a RatPoly copy.
        * @since 2012-03-02
        */
        public RatPoly toRatPoly()
        {
<span class="nc" id="L75">                RatPoly bd = new RatPoly() ;</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">                for(int i=0 ; i &lt; a.size() ; i++)</span>
<span class="nc" id="L77">                        bd.set(i, a.elementAt(i) ) ;</span>
<span class="nc" id="L78">                return bd;</span>
        }  /* toRatPoly */

        /** Retrieve a polynomial coefficient.
        * @param n the zero-based index of the coefficient. n=0 for the constant term. 
        * @return the polynomial coefficient in front of x^n.
        */
        public BigInteger at(final int n)
        {
<span class="nc bnc" id="L87" title="All 2 branches missed.">                if ( n &lt; a.size())</span>
<span class="nc" id="L88">                        return( a.elementAt(n) ) ;</span>
                else
<span class="nc" id="L90">                        return( BigInteger.ZERO ) ;</span>
        } /* at */

        /** Evaluate at some integer argument.
        * @param x The abscissa point of the evaluation
        * @return The polynomial value.
        * @since 2010-08-27
        * @author Richard J. Mathar
        */
        public BigInteger valueOf(final BigInteger x)
        {
<span class="nc bnc" id="L101" title="All 2 branches missed.">                if (a.size() == 0)</span>
<span class="nc" id="L102">                        return BigInteger.ZERO ;</span>
<span class="nc" id="L103">                BigInteger res = a.lastElement() ;</span>
                /* Heron casted form
                */
<span class="nc bnc" id="L106" title="All 2 branches missed.">                for(int i= a.size()-2 ; i &gt;=0 ; i--)</span>
<span class="nc" id="L107">                        res = res.multiply(x).add( a.elementAt(i) ) ;</span>
<span class="nc" id="L108">                return res ;</span>
        } /* valueOf */


        /** Horner scheme to find the function value at the argument x
        * @param x The argument x.
        * @return Value of the polynomial at x.
        * @since 2008-11-13
        */
        public BigInteger valueOf( int x)
        {
<span class="nc" id="L119">                return valueOf(new BigInteger(&quot;&quot;+x)) ;</span>
        } /* valueOf */

        /** Set a polynomial coefficient.
        * @param n the zero-based index of the coefficient. n=0 for the constant term. 
        *  If the polynomial has not yet the degree to need this coefficient,
        *  the intermediate coefficients are set to zero.
        * @param value the new value of the coefficient.
        */
        public void set(final int n, final BigInteger value)
        {
<span class="nc bnc" id="L130" title="All 2 branches missed.">                if ( n &lt; a.size())</span>
<span class="nc" id="L131">                        a.set(n,value) ;</span>
                else
                {
                        /* fill intermediate powers with coefficients of zero
                        */
<span class="nc bnc" id="L136" title="All 2 branches missed.">                        while ( a.size() &lt; n )</span>
                        {
<span class="nc" id="L138">                                a.add(BigInteger.ZERO ) ;</span>
                        }
<span class="nc" id="L140">                        a.add(value) ;</span>
                }
<span class="nc" id="L142">        } /* set */</span>

        /** Set a polynomial coefficient.
        * @param n the zero-based index of the coefficient. n=0 for the constant term. 
        *  If the polynomial has not yet the degree to need this coefficient,
        *  the intermediate coefficients are implicitly set to zero.
        * @param value the new value of the coefficient.
        */
        public void set(final int n, final int value)
        {
<span class="nc" id="L152">                BigInteger val2 = new BigInteger(&quot;&quot;+value) ;</span>
<span class="nc" id="L153">                set(n,val2) ;</span>
<span class="nc" id="L154">        } /* set */</span>

        /** Count of coefficients.
        * @return the number of polynomial coefficients.
        * Differs from the polynomial degree by one.
        */
        public int size()
        {
<span class="nc" id="L162">                return a.size() ;</span>
        } /* size */

        /** Polynomial degree.
        * @return the polynomial degree.
        */
        public int degree()
        {
<span class="nc" id="L170">                return a.size()-1 ;</span>
        } /* degree */

        /** Polynomial lower degree.
        * @return power of the smallest non-zero coefficient.
        * If the polynomial is identical to 0, 0 is returned.
        */
        public int ldegree()
        {
<span class="nc bnc" id="L179" title="All 2 branches missed.">                for(int n=0 ; n &lt; a.size() ; n++)</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                        if ( a.elementAt(n).compareTo(BigInteger.ZERO) != 0 )</span>
<span class="nc" id="L181">                                return n;</span>
<span class="nc" id="L182">                return 0 ;</span>
        } /* ldegree */

        /** Multiply by a constant factor.
        * @param val the factor
        * @return the product of this with the factor.
        *   All coefficients of this have been multiplied individually by the factor.
        * @since 2010-08-27
        */
        public BigIntegerPoly multiply(final BigInteger val)
        {
<span class="nc" id="L193">                BigIntegerPoly resul = new BigIntegerPoly() ;</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if ( val.compareTo(BigInteger.ZERO) != 0 )</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">                        for(int n=0; n &lt; a.size() ; n++)</span>
<span class="nc" id="L196">                                resul.set(n,a.elementAt(n).multiply(val) ) ;</span>
<span class="nc" id="L197">                return resul ;</span>
        } /* multiply */

        /** Multiply by another polynomial
        * @param val the other polynomial
        * @return the product of this with the other polynomial
        */
        public BigIntegerPoly multiply(final BigIntegerPoly val)
        {
<span class="nc" id="L206">                BigIntegerPoly resul = new BigIntegerPoly() ;</span>
                /* the degree of the result is the sum of the two degrees.
                */
<span class="nc" id="L209">                final int nmax = degree()+val.degree() ;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                for(int n=0; n &lt;= nmax ; n++)</span>
                {
<span class="nc" id="L212">                        BigInteger coef = BigInteger.ZERO ;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                        for(int nleft=0; nleft &lt;= n ; nleft++)</span>
<span class="nc" id="L214">                                coef = coef.add(at(nleft).multiply(val.at(n-nleft))) ;</span>
<span class="nc" id="L215">                        resul.set(n,coef) ;</span>
                }
<span class="nc" id="L217">                resul.simplify() ;</span>
<span class="nc" id="L218">                return resul ;</span>
        } /* multiply */

        /** Raise to a positive power.
        * @param n the exponent of the power
        * @return the n-th power of this.
        */
        public BigIntegerPoly pow(final int n) throws ArithmeticException
        {
<span class="nc" id="L227">                BigIntegerPoly resul = new BigIntegerPoly(&quot;1&quot;) ;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                if ( n &lt; 0 )</span>
<span class="nc" id="L229">                        throw new ArithmeticException(&quot;negative polynomial power &quot;+n) ;</span>
                else
                {
<span class="nc bnc" id="L232" title="All 2 branches missed.">                        for(int i=1 ; i &lt;= n ; i++)</span>
<span class="nc" id="L233">                                resul = resul.multiply(this) ;</span>
<span class="nc" id="L234">                        resul.simplify() ;</span>
<span class="nc" id="L235">                        return resul ;</span>
                }
        } /* pow */

        /** Add another polynomial
        * @param val the other polynomial
        * @return the sum of this with the other polynomial
        * @since 2010-08-27
        */
        public BigIntegerPoly add(final BigIntegerPoly val)
        {
<span class="nc" id="L246">                BigIntegerPoly resul = new BigIntegerPoly() ;</span>
                /* the degree of the result is the larger of the two degrees (before simplify() at least).
                */
<span class="nc bnc" id="L249" title="All 2 branches missed.">                final int nmax = (degree()&gt;val.degree()) ? degree() : val.degree() ;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                for(int n=0; n &lt;= nmax ; n++)</span>
                {
<span class="nc" id="L252">                        BigInteger coef = at(n).add(val.at(n)) ;</span>
<span class="nc" id="L253">                        resul.set(n,coef) ;</span>
                }
<span class="nc" id="L255">                resul.simplify() ;</span>
<span class="nc" id="L256">                return resul ;</span>
        } /* add */

        /** Subtract another polynomial
        * @param val the other polynomial
        * @return the difference between this and the other polynomial
        * @since 2008-10-25
        */
        public BigIntegerPoly subtract(final BigIntegerPoly val)
        {
<span class="nc" id="L266">                BigIntegerPoly resul = new BigIntegerPoly() ;</span>
                /* the degree of the result is the larger of the two degrees (before simplify() at least).
                */
<span class="nc bnc" id="L269" title="All 2 branches missed.">                final int nmax = (degree()&gt;val.degree()) ? degree() : val.degree() ;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                for(int n=0; n &lt;= nmax ; n++)</span>
                {
<span class="nc" id="L272">                        BigInteger coef = at(n).subtract(val.at(n)) ;</span>
<span class="nc" id="L273">                        resul.set(n,coef) ;</span>
                }
<span class="nc" id="L275">                resul.simplify() ;</span>
<span class="nc" id="L276">                return resul ;</span>
        } /* subtract */


        /** Divide by another polynomial.
        * @param val the other polynomial
        * @return A vector with [0] containg the polynomial of degree which is the
        *  difference of the degree of this and the degree of val. [1] the remainder polynomial.
        * This = returnvalue[0] + returnvalue[1]/val .
        * @since 2012-03-01
        */
        public BigIntegerPoly[] divideAndRemainder(final BigIntegerPoly val)
        {
<span class="nc" id="L289">                BigIntegerPoly[] ret = new BigIntegerPoly[2] ;</span>
                /* remove any high-order zeros. note that the clone() operation calls simplify().
                */
<span class="nc" id="L292">                BigIntegerPoly valSimpl = val.clone() ;</span>
<span class="nc" id="L293">                BigIntegerPoly thisSimpl = clone() ;</span>

                /* catch the case with val equal to zero
                */
<span class="nc bnc" id="L297" title="All 4 branches missed.">                if ( valSimpl.degree() == 0 &amp;&amp; valSimpl.a.firstElement().compareTo(BigInteger.ZERO) == 0)</span>
<span class="nc" id="L298">                        throw new ArithmeticException(&quot;Division through zero polynomial&quot;) ;</span>
                /* degree of this smaller than degree of val: remainder is this
                */
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if ( thisSimpl.degree() &lt; valSimpl.degree() )</span>
                {
                        /* leading polynomial equals zero 
                        */
<span class="nc" id="L305">                        ret[0] = new BigIntegerPoly() ;</span>
<span class="nc" id="L306">                        ret[1] = thisSimpl ;</span>
                }
                else
                {
                        /* long division. Highest degree by dividing the highest degree
                        * of this thru val. At this point an exception is thrown if the
                        * polynomial division cannot be done with integer coefficients.
                        */
<span class="nc" id="L314">                        ret[0] = new BigIntegerPoly() ;</span>
<span class="nc" id="L315">                        BigInteger[] newc = thisSimpl.a.lastElement().divideAndRemainder( valSimpl.a.lastElement()) ;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">                        if ( newc[1].compareTo(BigInteger.ZERO) != 0)</span>
<span class="nc" id="L317">                                throw new ArithmeticException(&quot;Incompatible leading term in &quot; + this + &quot; / &quot; + val) ;</span>
<span class="nc" id="L318">                        ret[0].set( thisSimpl.degree()-valSimpl.degree(),  newc[0]) ;</span>

                        /* recurrences: build this - val*(1-termresult) and feed this
                        * into another round of division. Have intermediate ret[0]+ret[1]/val.
                        */
<span class="nc" id="L323">                        ret[1] = thisSimpl.subtract( ret[0].multiply( valSimpl) );</span>

                        /* any remainder left ?
                        */
<span class="nc bnc" id="L327" title="All 2 branches missed.">                        if ( ret[1].degree() &lt; valSimpl.degree() )</span>
<span class="nc" id="L328">                                ;</span>
                        else
                        {
<span class="nc" id="L331">                                BigIntegerPoly rem[] = ret[1].divideAndRemainder(val) ;</span>
<span class="nc" id="L332">                                ret[0] = ret[0].add(rem[0]) ;</span>
<span class="nc" id="L333">                                ret[1] = rem[1] ;</span>
                        }
                }
<span class="nc" id="L336">                return ret ;</span>
        } /* divideAndRemainder */

        /** Print as a comma-separated list of coefficients.
        * @return the representation a0,a1,a2,a3,...
        * @since 2010-08-27
        */
        public String toString()
        {
<span class="nc" id="L345">                String str = new String();</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                for(int n=0; n &lt; a.size() ; n++)</span>
                {
<span class="nc bnc" id="L348" title="All 2 branches missed.">                        if ( n == 0 )</span>
<span class="nc" id="L349">                                str += a.elementAt(n).toString() ;</span>
                        else
<span class="nc" id="L351">                                str += &quot;,&quot;+a.elementAt(n).toString() ;</span>
                }
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if ( str.length() == 0 )</span>
<span class="nc" id="L354">                        str = &quot;0&quot; ;</span>
<span class="nc" id="L355">                return str ;</span>
        } /* toString */

        /** Print as a polyomial in x.
        * @return The representation a0+a1*x+a2*x^2+...
        *    The terms with zero coefficients are not mentioned.
        * @since 2008-10-26
        */
        public String toPString()
        {
<span class="nc" id="L365">                String str = new String();</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                for(int n=0; n &lt; a.size() ; n++)</span>
                {
<span class="nc" id="L368">                        final BigInteger num = a.elementAt(n) ;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                        if ( num.compareTo(BigInteger.ZERO) != 0 )</span>
                        {
<span class="nc" id="L371">                                str += &quot; &quot; ;</span>
<span class="nc bnc" id="L372" title="All 4 branches missed.">                                if ( num.compareTo(BigInteger.ZERO) &gt; 0 &amp;&amp; n&gt; 0)</span>
<span class="nc" id="L373">                                        str += &quot;+&quot; ;</span>
<span class="nc" id="L374">                                str += a.elementAt(n).toString() ;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                                if ( n &gt; 0 )</span>
                                {
<span class="nc" id="L377">                                        str += &quot;*x&quot; ;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                                        if ( n &gt; 1 ) </span>
<span class="nc" id="L379">                                                str += &quot;^&quot;+n ;</span>
                                }
                        }
                }
<span class="nc bnc" id="L383" title="All 2 branches missed.">                if ( str.length() == 0 )</span>
<span class="nc" id="L384">                        str = &quot;0&quot; ;</span>
<span class="nc" id="L385">                return str ;</span>
        } /* toPString */

        /** Simplify the representation.
        * Trailing values with zero coefficients (at high powers) are deleted.
        */
        protected void simplify()
        {
<span class="nc" id="L393">                int n = a.size()-1 ;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                if ( n &gt;= 0)</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                        while( a.elementAt(n).compareTo(BigInteger.ZERO) == 0 )</span>
                        {
<span class="nc" id="L397">                                a.removeElementAt(n) ;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                                if( --n &lt;0)</span>
<span class="nc" id="L399">                                        break ;</span>
                        }
<span class="nc" id="L401">        } /* simplify */</span>

        /** First derivative.
        * @return The first derivative with respect to the indeterminate variable.
        * @since 2008-10-26
        */
        public BigIntegerPoly derive()
        {
<span class="nc bnc" id="L409" title="All 2 branches missed.">                if ( a.size() &lt;= 1)</span>
                {
                        /* derivative of the constant is just zero
                        */
<span class="nc" id="L413">                        return new BigIntegerPoly() ;</span>
                }
                else
                {       
<span class="nc" id="L417">                        BigIntegerPoly d = new BigIntegerPoly() ;</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">                        for(int i=1 ; i &lt;= degree() ; i++)</span>
                        {
<span class="nc" id="L420">                                final BigInteger c = a.elementAt(i).multiply(new BigInteger(&quot;&quot;+i)) ;</span>
<span class="nc" id="L421">                                d.set(i-1,c) ;</span>
                        }
<span class="nc" id="L423">                        return d ;</span>
                }
        } /* derive */

        /** Truncate polynomial degree.
        * @return The polynomial with all coefficients beyond deg set to zero.
        * @since 2010-08-27
        */
        public BigIntegerPoly trunc(int newdeg)
        {
<span class="nc" id="L433">                BigIntegerPoly t = new BigIntegerPoly() ;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                for(int i=0; i &lt;= newdeg; i++)</span>
<span class="nc" id="L435">                        t.set(i,at(i)) ;</span>
<span class="nc" id="L436">                t.simplify() ;</span>
<span class="nc" id="L437">                return t ;</span>
        } /* trunc */

        /** Inverse Binomial transform.
        * @param maxdeg the maximum polynomial degree of the result
        * @return the sequence of coefficients is the inverse binomial transform of the original sequence.
        * @since 2010-08-29
        */
        public BigIntegerPoly binomialTInv(int maxdeg)
        {
<span class="nc" id="L447">                BigIntegerPoly r = new BigIntegerPoly() ;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                for(int i=0; i &lt;= maxdeg; i++)</span>
                {
<span class="nc" id="L450">                        BigInteger c = BigInteger.ZERO ;</span>
<span class="nc bnc" id="L451" title="All 4 branches missed.">                        for(int j=0; j &lt;= i &amp;&amp; j &lt; a.size(); j++)</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                                if ( (j+i) % 2 != 0 )</span>
<span class="nc" id="L453">                                        c = c.subtract( a.elementAt(j).multiply(BigIntegerMath.binomial(i,j)) ) ;</span>
                                else
<span class="nc" id="L455">                                        c = c.add( a.elementAt(j).multiply(BigIntegerMath.binomial(i,j)) ) ;</span>
<span class="nc" id="L456">                        r.set(i,c) ;</span>
                }
<span class="nc" id="L458">                r.simplify() ;</span>
<span class="nc" id="L459">                return r ;</span>
        } /* binomialTInv */


        /** Compute the order of the root r.
        * @return 1 for simple roots, 2 for order 2 etc., 0 if not a root
        * @since 2010-08-27
        */
        public int rootDeg(final BigInteger r)
        {
<span class="nc" id="L469">                int o = 0 ;</span>
<span class="nc" id="L470">                BigIntegerPoly d = clone() ;</span>
<span class="nc" id="L471">                BigInteger roo = d.valueOf(r) ;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                while ( roo.compareTo(BigInteger.ZERO) == 0 )</span>
                {
<span class="nc" id="L474">                        o++ ;</span>
<span class="nc" id="L475">                        d = d.derive() ;</span>
<span class="nc" id="L476">                        roo = d.valueOf(r) ;</span>
                }
<span class="nc" id="L478">                return o ;</span>
        } /* rootDeg */

        /** Generate the integer roots of the polynomial.
        * @return The vector of integer roots, without their multiplicity.
        * @since 2010-08-27
        */
        public Vector&lt;BigInteger&gt; iroots()
        {
                /* The vector of the roots */
<span class="nc" id="L488">                Vector&lt;BigInteger&gt; res =new Vector&lt;BigInteger&gt;() ;</span>

                /* collect the zero
                */
<span class="nc bnc" id="L492" title="All 2 branches missed.">                if ( a.firstElement().compareTo(BigInteger.ZERO) == 0 )</span>
<span class="nc" id="L493">                        res.add(BigInteger.ZERO) ;</span>

                /* collect the divisors of the constant element (or the reduced polynomial) */
<span class="nc" id="L496">                int l = ldegree() ;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if ( a.elementAt(l).compareTo(BigInteger.ZERO) != 0 )</span>
                {
<span class="nc" id="L499">                        Vector&lt;BigInteger&gt; cand = BigIntegerMath.divisors(a.elementAt(l).abs()) ;</span>
        
                        /* check the divisors (both signs) */
<span class="nc bnc" id="L502" title="All 2 branches missed.">                        for(int i=0 ; i &lt; cand.size() ; i++)</span>
                        {
<span class="nc" id="L504">                                BigInteger roo = valueOf( cand.elementAt(i) ) ;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                                if ( roo.compareTo(BigInteger.ZERO) == 0 )</span>
                                        /* found a root cand[i] */
<span class="nc" id="L507">                                        res.add(cand.elementAt(i)) ;</span>
<span class="nc" id="L508">                                roo = valueOf( cand.elementAt(i).negate() ) ;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">                                if ( roo.compareTo(BigInteger.ZERO) == 0 )</span>
<span class="nc" id="L510">                                        res.add(cand.elementAt(i).negate()) ;</span>
                        }
                }
<span class="nc" id="L513">                return res;</span>
        } /* iroots */

        /** Generate the factors which are 2nd degree polynomials.
        * @return A (potentially empty) vector of factors, without multiplicity.
        *  Only factors with non-zero absolute coefficient are generated.
        *  This means the factors are of the form x^2+a*x+b=0 with nonzero b.
        * @since 2012-03-01
        */
        protected Vector&lt;BigIntegerPoly&gt; i2roots()
        {
                /* The vector of the factors to be returned
                */
<span class="nc" id="L526">                Vector&lt;BigIntegerPoly&gt; res =new Vector&lt;BigIntegerPoly&gt;() ;</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">                if ( degree() &lt; 2)</span>
<span class="nc" id="L529">                        return res ;</span>

<span class="nc" id="L531">                BigInteger bsco = a.firstElement().abs() ;</span>
<span class="nc" id="L532">                Vector&lt;BigInteger&gt; b = BigIntegerMath.divisors(bsco) ;</span>
<span class="nc" id="L533">                BigInteger csco = a.lastElement().abs() ;</span>
<span class="nc" id="L534">                Vector&lt;BigInteger&gt; c = BigIntegerMath.divisors(csco) ;</span>

                /* Generate the floating point values of roots. To have some reasonable
                * accuracy in the results, add zeros to the integer coefficients, scaled
                * by the expected division with values of b (which are all &lt;= a.firstele).
                * Number of decimal digits in bsco by using a log2-&gt;log10 rough estimate
                * and adding 6 safety digits
                */
<span class="nc" id="L542">                RatPoly thisDec = toRatPoly() ;</span>
<span class="nc" id="L543">                Vector&lt;BigComplex&gt; roo = thisDec.roots(6+(int)(0.3*bsco.bitCount()) ) ;</span>

<span class="nc" id="L545">                final BigDecimal half = new BigDecimal(&quot;0.5&quot;) ;</span>

                /* for each of the roots z try to see whether c*z^2+a*z+b=0 with integer a, b and c
                * where b is restricted to a signed divisor of the constant coefficient.
                * Solve z*(c*z+a)=-b or c*z+a = -b/z or -b/z-c*z = some integer a.
                */
<span class="nc bnc" id="L551" title="All 2 branches missed.">                for( BigComplex z : roo)</span>
                {
<span class="nc bnc" id="L553" title="All 2 branches missed.">                        for(BigInteger bco : b)</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                        for(BigInteger cco : c)</span>
                        {
                                /* the major reason to avoid the case b=0 is that this would
                                * require precaution of double counting below. Note that this
                                * case is already covered by using iroots().
                                */
<span class="nc bnc" id="L560" title="All 2 branches missed.">                                if ( bco.signum() != 0 )</span>
                                {
<span class="nc bnc" id="L562" title="All 2 branches missed.">                                        for(int sig = -1 ; sig &lt;=1 ; sig +=2)</span>
                                        {
<span class="nc bnc" id="L564" title="All 2 branches missed.">                                                BigInteger bcosig = (sig &gt; 0 )? bco : bco.negate() ;</span>
                                                /* -a = b/z+c*z has real part b*Re(z)/|z|^2+c*Re(z) = Re z *( b/|z|^2+c)
                                                */
<span class="nc" id="L567">                                                BigDecimal negA = BigDecimalMath.add(BigDecimalMath.divideRound(bcosig,z.norm()),cco) ;</span>
<span class="nc" id="L568">                                                negA = negA.multiply(z.re) ;</span>
                                                /* convert to a with round-to-nearest
                                                */
<span class="nc" id="L571">                                                BigInteger a = negA.negate().add(half).toBigInteger() ;</span>
                
                                                /* test the polynomial remainder. if zero, add the term
                                                * to the results.
                                                */
<span class="nc" id="L576">                                                BigIntegerPoly dtst = new BigIntegerPoly(&quot;&quot;+bcosig+&quot;,&quot;+a+&quot;,&quot;+cco) ;</span>
                                                try 
                                                {
<span class="nc" id="L579">                                                        BigIntegerPoly[] rm = divideAndRemainder(dtst) ;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                                                        if ( rm[1].isZero() )</span>
<span class="nc" id="L581">                                                                res.add(dtst) ;</span>
                                                }
<span class="nc" id="L583">                                                catch ( ArithmeticException ex)</span>
                                                {
<span class="nc" id="L585">                                                }</span>
                                        }
                                }
<span class="nc" id="L588">                        }</span>
<span class="nc" id="L589">                }</span>

<span class="nc" id="L591">                return res;</span>
        } /* i2roots */

        /** Test whether this polynomial value is zero.
        * @return If this is a polynomial p(x)=0 for all x.
        */
        public boolean isZero()
        {
<span class="nc" id="L599">                simplify() ;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                return (a.size() ==0 ) ;</span>
        }

        /** Factorization into integer polynomials.
        * The current factorization detects only factors which are polynomials of order up to 2.
        * @return The vector of factors. Factors with higher multiplicity are represented by repetition.
        * @since 2012-03-01
        */
        public Vector&lt;BigIntegerPoly&gt; ifactor()
        {
                /* this ought be entirely rewritten in terms of the LLL algorithm
                */
<span class="nc" id="L612">                Vector&lt;BigIntegerPoly&gt; fac = new Vector&lt;BigIntegerPoly&gt;() ;</span>

                /* collect integer roots (polynomial factors of degree 1) */
<span class="nc" id="L615">                Vector&lt;BigInteger&gt; r = iroots() ;</span>
<span class="nc" id="L616">                BigIntegerPoly[] res = new BigIntegerPoly[2] ;</span>
<span class="nc" id="L617">                res[0] = this ;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                for( BigInteger i : r)</span>
                {
<span class="nc" id="L620">                        int deg = rootDeg(i) ;</span>
                        /* construct  the factor x-i */
<span class="nc" id="L622">                        BigIntegerPoly f = new BigIntegerPoly(&quot;&quot;+i.negate()+&quot;,1&quot;) ;</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">                        for(int mu =0 ; mu &lt; deg ; mu++)</span>
                        {
<span class="nc" id="L625">                                fac.add(f) ;</span>
<span class="nc" id="L626">                                res = res[0].divideAndRemainder(f) ;</span>
                        }
<span class="nc" id="L628">                }</span>

                /* collect factors which are polynomials of degree 2
                */
<span class="nc" id="L632">                Vector&lt;BigIntegerPoly&gt; pol2 = i2roots() ;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                for( BigIntegerPoly i : pol2)</span>
                {
                        /* the internal loop catches cases with higher
                        * powers of individual polynomials (of actual degree 2 or 4...)
                        */
<span class="nc bnc" id="L638" title="All 2 branches missed.">                        while ( res[0].degree() &gt;= 2)</span>
                        {
                                try
                                {
<span class="nc" id="L642">                                        BigIntegerPoly[] dtst  = res[0].divideAndRemainder(i) ;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                                        if ( dtst[1].isZero() )</span>
                                        {
<span class="nc" id="L645">                                                fac.add(i) ;</span>
<span class="nc" id="L646">                                                res = dtst ;</span>
                                        }
                                        else
<span class="nc" id="L649">                                                break ;</span>
                                }
<span class="nc" id="L651">                                catch(ArithmeticException ex)</span>
                                {
<span class="nc" id="L653">                                        break ;</span>
<span class="nc" id="L654">                                }</span>
                        }
<span class="nc" id="L656">                }</span>

                /* add remaining factor, if not equal to 1
                */
<span class="nc bnc" id="L660" title="All 4 branches missed.">                if ( res[0].degree() &gt;0 || res[0].a.firstElement().compareTo (BigInteger.ONE) != 0 )</span>
<span class="nc" id="L661">                        fac.add(res[0]) ;</span>
<span class="nc" id="L662">                return fac ;</span>
        } /* ifactor */


} /* BigIntegerPoly */
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>