<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BigSurd.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment for class CS5010</a> &gt; <a href="index.source.html" class="el_package">org.nevec.rjm</a> &gt; <span class="el_source">BigSurd.java</span></div><h1>BigSurd.java</h1><pre class="source lang-java linenums">package org.nevec.rjm ;

import java.util.* ;
import java.security.* ;
import java.math.* ;

/** Square roots on the real line.
* These represent numbers which are a product of a (signed) fraction by
* a square root of a non-negative fraction.
* This might be extended to values on the imaginary axis by allowing negative
* values underneath the square root, but this is not yet implemented.
* @since 2011-02-12
* @author Richard J. Mathar
*/
public class BigSurd implements Cloneable, Comparable&lt;BigSurd&gt;
{
        /** The value of zero.
        */
<span class="nc" id="L19">        static public BigSurd ZERO = new BigSurd() ;</span>

        /** The value of one.
        */
<span class="nc" id="L23">        static public BigSurd ONE = new BigSurd(Rational.ONE,Rational.ONE) ;</span>
        /** Prefactor
        */
        Rational pref ;

        /** The number underneath the square root, always non-negative.
        * The mathematical object has the value pref*sqrt(disc).
        */
        Rational disc ;

        /** Default ctor, which represents the zero.
        * @since 2011-02-12
        */
        public BigSurd()
<span class="nc" id="L37">        {</span>
<span class="nc" id="L38">                pref = Rational.ZERO ;</span>
<span class="nc" id="L39">                disc = Rational.ZERO ;</span>
<span class="nc" id="L40">        }</span>

        /** ctor given the prefactor and the basis of the root.
        * This creates an object of value a*sqrt(b).
        * @param a the prefactor.
        * @param b the discriminant.
        * @since 2011-02-12
        */
        public BigSurd(Rational a, Rational b)
<span class="nc" id="L49">        {</span>
<span class="nc" id="L50">                this.pref = a ;</span>
                /* reject attempts to use a negative b
                */
<span class="nc bnc" id="L53" title="All 2 branches missed.">                if ( b.signum() &lt; 0 )</span>
<span class="nc" id="L54">                        throw new ProviderException(&quot;Not implemented: imaginary surds&quot;) ;</span>
<span class="nc" id="L55">                this.disc = b ;</span>
<span class="nc" id="L56">                normalize() ;</span>
<span class="nc" id="L57">                normalizeG() ;</span>
<span class="nc" id="L58">        }</span>

        /** ctor given the numerator and denominator of the root.
        * This creates an object of value sqrt(a/b).
        * @param a the numerator
        * @param b the denominator.
        * @since 2011-02-12
        */
        public BigSurd(int a, int b)
        {
<span class="nc" id="L68">                this( Rational.ONE, new Rational(a,b) ) ;</span>
<span class="nc" id="L69">        }</span>

        /** ctor given the value under the root.
        * This creates an object of value sqrt(a).
        * @param a the discriminant.
        * @since 2011-02-12
        */
        public BigSurd(BigInteger a)
        {
<span class="nc" id="L78">                this( Rational.ONE, new Rational(a,BigInteger.ONE) ) ;</span>
<span class="nc" id="L79">        }</span>

        /** Create a deep copy.
        * @since 2011-02-12
        */
        public BigSurd clone()
        {
<span class="nc" id="L86">                Rational fclon = pref.clone() ;</span>
<span class="nc" id="L87">                Rational dclon = disc.clone() ;</span>
                /* the main intent here is to bypass any attempt to reduce the discriminant
                * by figuring out the square-free part in normalize(), which has already done
                * in the current copy of the number.
                */
<span class="nc" id="L92">                BigSurd cl = new BigSurd() ;</span>
<span class="nc" id="L93">                cl.pref = fclon ;</span>
<span class="nc" id="L94">                cl.disc = dclon ;</span>
<span class="nc" id="L95">                return cl ;</span>
        } /* BigSurd.clone */

        /** Add two surds of compatible discriminant.
        * @param val The value to be added to this.
        */
        public BigSurdVec add(final BigSurd val)
        {
                /* zero plus somethings yields something
                */
<span class="nc bnc" id="L105" title="All 2 branches missed.">                if ( signum() == 0 )</span>
<span class="nc" id="L106">                        return new BigSurdVec(val) ;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                else if (val.signum() == 0  )</span>
<span class="nc" id="L108">                        return new BigSurdVec(this) ;</span>
                else
                        /* let the ctor of BigSurdVec to the work */
<span class="nc" id="L111">                        return new BigSurdVec(this,val) ;</span>
        } /* add */

        /** Multiply by another square root.
        * @param val a second number of this type.
        * @return the product of this with the val.
        * @since 2011-02-12
        */
        public BigSurd multiply(final BigSurd val)
        {
<span class="nc" id="L121">                return new BigSurd( pref.multiply(val.pref), disc.multiply(val.disc) ) ;</span>
        } /* BigSurd.multiply */

        /** Multiply by a rational number.
        * @param val the factor.
        * @return the product of this with the val.
        * @since 2011-02-15
        */
        public BigSurd multiply(final Rational val)
        {
<span class="nc" id="L131">                return new BigSurd( pref.multiply(val), disc) ;</span>
        } /* BigSurd.multiply */

        /** Multiply by a BigInteger.
        * @param val a second number.
        * @return the product of this with the value.
        * @since 2011-02-12
        */
        public BigSurd multiply(final BigInteger val)
        {
<span class="nc" id="L141">                return new BigSurd(pref.multiply(val), disc) ;</span>
        } /* BigSurd.multiply */

        /** Multiply by an integer.
        * @param val a second number.
        * @return the product of this with the value.
        * @since 2011-02-12
        */
        public BigSurd multiply(final int val)
        {
<span class="nc" id="L151">                BigInteger tmp = new BigInteger(&quot;&quot;+val) ;</span>
<span class="nc" id="L152">                return multiply(tmp) ;</span>
        } /* BigSurd.multiply */


        /** Compute the square.
        * @return this value squared.
        * @since 2011-02-12
        */
        public Rational sqr()
        {
<span class="nc" id="L162">                Rational res = pref.pow(2) ;</span>
<span class="nc" id="L163">                res = res.multiply(disc) ;</span>
<span class="nc" id="L164">                return res;</span>
        } /* BigSurd.sqr */

        /** Divide by another square root.
        * @param val A second number of this type.
        * @return The value of this/val
        * @since 2011-02-12
        */
        public BigSurd divide(final BigSurd val)
        {
<span class="nc bnc" id="L174" title="All 2 branches missed.">                if( val.signum() == 0 )</span>
<span class="nc" id="L175">                        throw new ArithmeticException(&quot;Dividing &quot;+ toString() + &quot; through zero.&quot;) ;</span>
<span class="nc" id="L176">                return new BigSurd( pref.divide(val.pref), disc.divide(val.disc) ) ;</span>
        } /* BigSurd.divide */

        /** Divide by an integer.
        * @param val a second number.
        * @return the value of this/val
        * @since 2011-02-12
        */
        public BigSurd divide(final BigInteger val)
        {
<span class="nc bnc" id="L186" title="All 2 branches missed.">                if( val.signum() == 0 )</span>
<span class="nc" id="L187">                        throw new ArithmeticException(&quot;Dividing &quot;+ toString() + &quot; through zero.&quot;) ;</span>
<span class="nc" id="L188">                return new BigSurd( pref.divide(val), disc ) ;</span>
        } /* BigSurd.divide */

        /** Divide by an integer.
        * @param val A second number.
        * @return The value of this/val
        * @since 2011-02-12
        */
        public BigSurd divide(int val)
        {
<span class="nc bnc" id="L198" title="All 2 branches missed.">                if( val == 0 )</span>
<span class="nc" id="L199">                        throw new ArithmeticException(&quot;Dividing &quot;+ toString() + &quot; through zero.&quot;) ;</span>
<span class="nc" id="L200">                return new BigSurd( pref.divide(val), disc ) ;</span>
        } /* BigSurd.divide */

        /** Compute the negative.
        * @return -this.
        * @since 2011-02-12
        */
        public BigSurd negate()
        {
                /* This is trying to be quick, avoiding normalize(), by toggling
                * the sign in a clone()
                */
<span class="nc" id="L212">                BigSurd n = clone() ;</span>
<span class="nc" id="L213">                n.pref = n.pref.negate() ;</span>
<span class="nc" id="L214">                return n ;</span>
        } /* BigSurd.negate */

        /** Absolute value.
        * @return The absolute (non-negative) value of this.
        * @since 2011-02-12
        */
        public BigSurd abs()
        {
<span class="nc" id="L223">                return new BigSurd(pref.abs(),disc) ;</span>
        }

        /** Compares the value of this with another constant.
        * @param val the other constant to compare with
        * @return -1, 0 or 1 if this number is numerically less than, equal to,
        *    or greater than val.
        * @since 2011-02-12
        */
        public int compareTo(final BigSurd val)
        {
                /* Since we keep the discriminant positive, the rough estimate
                * comes from comparing the signs of the prefactors.
                */
<span class="nc" id="L237">                final int sig = signum() ;</span>
<span class="nc" id="L238">                final int sigv = val.signum() ;</span>
<span class="nc bnc" id="L239" title="All 4 branches missed.">                if ( sig &lt; 0 &amp;&amp; sigv &gt;= 0 )</span>
<span class="nc" id="L240">                        return -1 ;</span>
<span class="nc bnc" id="L241" title="All 4 branches missed.">                if ( sig &gt; 0 &amp;&amp; sigv &lt;= 0 )</span>
<span class="nc" id="L242">                        return 1 ;</span>
<span class="nc bnc" id="L243" title="All 4 branches missed.">                if ( sig == 0 &amp;&amp; sigv == 0 )</span>
<span class="nc" id="L244">                        return 0 ;</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">                if ( sig == 0 &amp;&amp; sigv &gt; 0 )</span>
<span class="nc" id="L246">                        return -1 ;</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">                if ( sig == 0 &amp;&amp; sigv &lt; 0 )</span>
<span class="nc" id="L248">                        return 1 ;</span>

                /* Work out the cases of equal sign. Compare absolute values by comparison
                * of the squares which is forwarded to the comparison of the Rational class.
                */
<span class="nc" id="L253">                final Rational this2 = sqr() ;</span>
<span class="nc" id="L254">                final Rational val2 = val.sqr() ;</span>
<span class="nc" id="L255">                final int c = this2.compareTo(val2) ;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">                if ( c == 0 )</span>
<span class="nc" id="L257">                        return 0 ;</span>
                /* If both values have negative sign, the one with the smaller square is the larger number.
                */
<span class="nc bnc" id="L260" title="All 8 branches missed.">                else if ( sig &gt;0 &amp;&amp; c &gt;0 || sig &lt;0 &amp;&amp; c &lt;0 )</span>
<span class="nc" id="L261">                        return 1;</span>
                else
<span class="nc" id="L263">                        return -1 ;</span>
        } /* BigSurd.compareTo */

        /** Return a string in the format (number/denom)*()^(1/2).
        * If the discriminant equals 1, print just the prefactor.
        * @return the human-readable version in base 10
        * @since 2011-02-12
        */
        public String toString()
        {
<span class="nc bnc" id="L273" title="All 4 branches missed.">                if ( disc.compareTo(Rational.ONE) != 0 &amp;&amp; disc.compareTo(Rational.ZERO) != 0)</span>
<span class="nc" id="L274">                        return( &quot;(&quot;+pref.toString()+&quot;)*(&quot;+disc.toString()+&quot;)^(1/2)&quot; ) ;</span>
                else
<span class="nc" id="L276">                        return pref.toString() ;</span>
        } /* BigSurd.toString */

        /** Return a double value representation.
        * @return The value with double precision.
        * @since 2011-02-12
        */
        public double doubleValue()
        {
                /* First compute the square to prevent overflows if the two pieces of
                * the prefactor and the discriminant are of very different magnitude.
                */
<span class="nc" id="L288">                Rational p2 = pref.pow(2).multiply(disc) ;</span>
<span class="nc" id="L289">System.out.println(&quot;dv sq &quot; + p2.toString()) ;</span>
<span class="nc" id="L290">                double res = p2.doubleValue() ;</span>
<span class="nc" id="L291">System.out.println(&quot;dv sq &quot; + res) ;</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                return (pref.signum() &gt;= 0) ? Math.sqrt(res) : -Math.sqrt(res) ;</span>
        } /* BigSurd.doubleValue */

        /** Return a float value representation.
        * @return The value with single precision.
        * @since 2011-02-12
        */
        public float floatValue()
        {
<span class="nc" id="L301">                return (float)(doubleValue()) ;</span>
        } /* BigSurd.floatValue */

        /** True if the value is integer.
        * Equivalent to the indication whether a conversion to an integer
        * can be exact.
        * @since 2011-02-12
        */
        public boolean isBigInteger()
        {
<span class="nc bnc" id="L311" title="All 6 branches missed.">                return pref.isBigInteger() &amp;&amp; ( disc.signum() ==0 || disc.compareTo(Rational.ONE) == 0 ) ;</span>
        } /* BigSurd.isBigInteger */

        /** True if the value is rational.
        * Equivalent to the indication whether a conversion to a Rational can be exact.
        * @since 2011-02-12
        */
        public boolean isRational()
        {
<span class="nc bnc" id="L320" title="All 4 branches missed.">                return ( disc.signum() ==0 || disc.compareTo(Rational.ONE) == 0 ) ;</span>
        } /* BigSurd.isRational */

        /** Convert to a rational value if possible
        * @since 2012-02-15
        */
        public Rational toRational()
        {
<span class="nc bnc" id="L328" title="All 2 branches missed.">                if ( isRational() )</span>
<span class="nc" id="L329">                        return pref ;</span>
                else
<span class="nc" id="L331">                        throw new ArithmeticException(&quot;Undefined conversion &quot;+ toString() + &quot; to Rational.&quot;) ;</span>
        } /* BigSurd.toRational */

        /** The sign: 1 if the number is &gt;0, 0 if ==0, -1 if &lt;0
        * @return the signum of the value.
        * @since 2011-02-12
        */
        public int signum()
        {
                /* Since the disc is kept positive, this is the same
                * as the sign of the prefactor. This works because a zero discriminant
                * is always copied over to the prefactor, not hidden.
                */
<span class="nc" id="L344">                return pref.signum() ;</span>
        } /* BigSurd.signum */

        /** Normalize to squarefree discriminant.
        * @since 2011-02-12
        */
        protected void normalize()
        {
                /* Move squares out of the numerator and denominator of the discriminant
                */
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if ( disc.signum() != 0 )</span>
                {
                        /* square-free part of the numerator: numer = numC*some^2
                        */
<span class="nc" id="L358">                        BigInteger numC = BigIntegerMath.core(disc.numer()) ;</span>
                        /* extract the perfect square of the numerator
                        */
<span class="nc" id="L361">                        BigInteger sq = disc.numer().divide(numC) ;</span>
                        /* extract the associated square root
                        */
<span class="nc" id="L364">                        BigInteger sqf = BigIntegerMath.isqrt(sq) ;</span>

                        /* move sqf over to the pre-factor
                        */
<span class="nc" id="L368">                        pref = pref.multiply(sqf) ;</span>

<span class="nc" id="L370">                        BigInteger denC = BigIntegerMath.core(disc.denom()) ;</span>
<span class="nc" id="L371">                        sq = disc.denom().divide(denC) ;</span>
<span class="nc" id="L372">                        sqf = BigIntegerMath.isqrt(sq) ;</span>
<span class="nc" id="L373">                        pref = pref.divide(sqf) ;</span>

<span class="nc" id="L375">                        disc = new Rational(numC,denC) ;</span>
<span class="nc" id="L376">                }</span>
                else
<span class="nc" id="L378">                        pref = Rational.ZERO ;</span>
<span class="nc" id="L379">        } /* BigSurd.normalize */</span>

        /** Normalize to coprime numerator and denominator in prefactor and discriminant
        * @since 2011-02-12
        */
        protected void normalizeG()
        {
                /* Is there a common factor between the numerator of the prefactor
                * and the denominator of the discriminant ?
                */
<span class="nc" id="L389">                BigInteger d = pref.numer().abs().gcd( disc.denom()) ;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                if ( d.compareTo(BigInteger.ONE) &gt; 0 )</span>
                {
<span class="nc" id="L392">                        pref = pref.divide(d) ;</span>
                        /* instead of multiplying with the square of d, using two steps
                        * offers a change to recognize the common factor..
                        */
<span class="nc" id="L396">                        disc = disc.multiply(d) ;</span>
<span class="nc" id="L397">                        disc = disc.multiply(d) ;</span>
                }
                /* Is there a common factor between the denominator of the prefactor
                * and the numerator of the discriminant ?
                */
<span class="nc" id="L402">                d = pref.denom().gcd( disc.numer()) ;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if ( d.compareTo(BigInteger.ONE) &gt; 0 )</span>
                {
<span class="nc" id="L405">                        pref = pref.multiply(d) ;</span>
                        /* instead of dividing through the square of d, using two steps
                        * offers a change to recognize the common factor..
                        */
<span class="nc" id="L409">                        disc = disc.divide(d) ;</span>
<span class="nc" id="L410">                        disc = disc.divide(d) ;</span>
                }
<span class="nc" id="L412">        } /* BigSurd.normalizeG */</span>

        /** Return the approximate floating point representation.
        * @param mc Description of the accuracy needed.
        * @return A representation with digits valid as described by mc
        * @since 2012-02-15
        */
        public BigDecimal BigDecimalValue(MathContext mc)
        {
                /* the relative error of the result equals the relative error of the
                * prefactor plus half of the relative error of the discriminant.
                * So adding 3 digits temporarily is sufficient.
                */
<span class="nc" id="L425">                final MathContext locmc = new MathContext(mc.getPrecision()+3,mc.getRoundingMode()) ;</span>
                /* first the square root of the discriminant
                */
<span class="nc" id="L428">                BigDecimal sqrdis = BigDecimalMath.sqrt(disc.BigDecimalValue(locmc),locmc ) ;</span>
                /* Then multiply by the prefactor. If sqrdis is a terminating decimal fraction,
                * we prevent early truncation of the result by truncating later.
                */
<span class="nc" id="L432">                BigDecimal res = sqrdis.multiply(pref.BigDecimalValue(mc)) ;</span>
<span class="nc" id="L433">                return BigDecimalMath.scalePrec(res,mc) ;</span>
        } /* BigDecimalValue */



} /* BigSurd */

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>