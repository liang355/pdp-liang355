<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BigDecimalMath.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Assignment for class CS5010</a> &gt; <a href="index.source.html" class="el_package">org.nevec.rjm</a> &gt; <span class="el_source">BigDecimalMath.java</span></div><h1>BigDecimalMath.java</h1><pre class="source lang-java linenums">package org.nevec.rjm ;

import java.security.* ;
import java.util.* ;
import java.math.* ;


/** BigDecimal special functions.
* &lt;a href=&quot;http://arxiv.org/abs/0908.3030&quot;&gt;A Java Math.BigDecimal Implementation of Core Mathematical Functions&lt;/a&gt;
* @since 2009-05-22
* @author Richard J. Mathar
* @see &lt;a href=&quot;http://apfloat.org/&quot;&gt;apfloat&lt;/a&gt;
* @see &lt;a href=&quot;http://dfp.sourceforge.net/&quot;&gt;dfp&lt;/a&gt;
* @see &lt;a href=&quot;http://jscience.org/&quot;&gt;JScience&lt;/a&gt;
*/
<span class="nc" id="L16">public class BigDecimalMath</span>
{

        /** The base of the natural logarithm in a predefined accuracy.
        * http://www.cs.arizona.edu/icon/oddsends/e.htm
        * The precision of the predefined constant is one less than
        * the string's length, taking into account the decimal dot.
        * static int E_PRECISION = E.length()-1 ;
        */
<span class="nc" id="L25">        static BigDecimal E = new BigDecimal(&quot;2.71828182845904523536028747135266249775724709369995957496696762772407663035354&quot;+</span>
&quot;759457138217852516642742746639193200305992181741359662904357290033429526059563&quot;+
&quot;073813232862794349076323382988075319525101901157383418793070215408914993488416&quot;+
&quot;750924476146066808226480016847741185374234544243710753907774499206955170276183&quot;+
&quot;860626133138458300075204493382656029760673711320070932870912744374704723069697&quot;+
&quot;720931014169283681902551510865746377211125238978442505695369677078544996996794&quot;+
&quot;686445490598793163688923009879312773617821542499922957635148220826989519366803&quot;+
&quot;318252886939849646510582093923982948879332036250944311730123819706841614039701&quot;+
&quot;983767932068328237646480429531180232878250981945581530175671736133206981125099&quot;+
&quot;618188159304169035159888851934580727386673858942287922849989208680582574927961&quot;+
&quot;048419844436346324496848756023362482704197862320900216099023530436994184914631&quot;+
&quot;409343173814364054625315209618369088870701676839642437814059271456354906130310&quot;+
&quot;720851038375051011574770417189861068739696552126715468895703503540212340784981&quot;+
&quot;933432106817012100562788023519303322474501585390473041995777709350366041699732&quot;+
&quot;972508868769664035557071622684471625607988265178713419512466520103059212366771&quot;+
&quot;943252786753985589448969709640975459185695638023637016211204774272283648961342&quot;+
&quot;251644507818244235294863637214174023889344124796357437026375529444833799801612&quot;+
&quot;549227850925778256209262264832627793338656648162772516401910590049164499828931&quot;) ;

        /** Euler's constant Pi.
        * http://www.cs.arizona.edu/icon/oddsends/pi.htm
        */
<span class="nc" id="L47">        static BigDecimal PI = new BigDecimal(&quot;3.14159265358979323846264338327950288419716939937510582097494459230781640628620&quot;+</span>
&quot;899862803482534211706798214808651328230664709384460955058223172535940812848111&quot;+
&quot;745028410270193852110555964462294895493038196442881097566593344612847564823378&quot;+
&quot;678316527120190914564856692346034861045432664821339360726024914127372458700660&quot;+
&quot;631558817488152092096282925409171536436789259036001133053054882046652138414695&quot;+
&quot;194151160943305727036575959195309218611738193261179310511854807446237996274956&quot;+
&quot;735188575272489122793818301194912983367336244065664308602139494639522473719070&quot;+
&quot;217986094370277053921717629317675238467481846766940513200056812714526356082778&quot;+
&quot;577134275778960917363717872146844090122495343014654958537105079227968925892354&quot;+
&quot;201995611212902196086403441815981362977477130996051870721134999999837297804995&quot;+
&quot;105973173281609631859502445945534690830264252230825334468503526193118817101000&quot;+
&quot;313783875288658753320838142061717766914730359825349042875546873115956286388235&quot;+
&quot;378759375195778185778053217122680661300192787661119590921642019893809525720106&quot;+
&quot;548586327886593615338182796823030195203530185296899577362259941389124972177528&quot;+
&quot;347913151557485724245415069595082953311686172785588907509838175463746493931925&quot;+
&quot;506040092770167113900984882401285836160356370766010471018194295559619894676783&quot;+
&quot;744944825537977472684710404753464620804668425906949129331367702898915210475216&quot;+
&quot;205696602405803815019351125338243003558764024749647326391419927260426992279678&quot;+
&quot;235478163600934172164121992458631503028618297455570674983850549458858692699569&quot;+
&quot;092721079750930295532116534498720275596023648066549911988183479775356636980742&quot;+
&quot;654252786255181841757467289097777279380008164706001614524919217321721477235014&quot;) ;

        /** Euler-Mascheroni constant lower-case gamma.
        * http://www.worldwideschool.org/library/books/sci/math/MiscellaneousMathematicalConstants/chap35.html
        */
<span class="nc" id="L72">        static BigDecimal GAMMA = new BigDecimal(&quot;0.577215664901532860606512090082402431&quot;+</span>
&quot;0421593359399235988057672348848677267776646709369470632917467495146314472498070&quot;+
&quot;8248096050401448654283622417399764492353625350033374293733773767394279259525824&quot;+
&quot;7094916008735203948165670853233151776611528621199501507984793745085705740029921&quot;+
&quot;3547861466940296043254215190587755352673313992540129674205137541395491116851028&quot;+
&quot;0798423487758720503843109399736137255306088933126760017247953783675927135157722&quot;+
&quot;6102734929139407984301034177717780881549570661075010161916633401522789358679654&quot;+
&quot;9725203621287922655595366962817638879272680132431010476505963703947394957638906&quot;+
&quot;5729679296010090151251959509222435014093498712282479497471956469763185066761290&quot;+
&quot;6381105182419744486783638086174945516989279230187739107294578155431600500218284&quot;+
&quot;4096053772434203285478367015177394398700302370339518328690001558193988042707411&quot;+
&quot;5422278197165230110735658339673487176504919418123000406546931429992977795693031&quot;+
&quot;0050308630341856980323108369164002589297089098548682577736428825395492587362959&quot;+
&quot;6133298574739302373438847070370284412920166417850248733379080562754998434590761&quot;+
&quot;6431671031467107223700218107450444186647591348036690255324586254422253451813879&quot;+
&quot;1243457350136129778227828814894590986384600629316947188714958752549236649352047&quot;+
&quot;3243641097268276160877595088095126208404544477992299157248292516251278427659657&quot;+
&quot;0832146102982146179519579590959227042089896279712553632179488737642106606070659&quot;+
&quot;8256199010288075612519913751167821764361905705844078357350158005607745793421314&quot;+
&quot;49885007864151716151945&quot;);

        /** Natural logarithm of 2.
        * http://www.worldwideschool.org/library/books/sci/math/MiscellaneousMathematicalConstants/chap58.html
        */
<span class="nc" id="L96">        static BigDecimal LOG2 = new BigDecimal(&quot;0.693147180559945309417232121458176568075&quot;+</span>
&quot;50013436025525412068000949339362196969471560586332699641868754200148102057068573&quot;+
&quot;368552023575813055703267075163507596193072757082837143519030703862389167347112335&quot;+
&quot;011536449795523912047517268157493206515552473413952588295045300709532636664265410&quot;+
&quot;423915781495204374043038550080194417064167151864471283996817178454695702627163106&quot;+
&quot;454615025720740248163777338963855069526066834113727387372292895649354702576265209&quot;+
&quot;885969320196505855476470330679365443254763274495125040606943814710468994650622016&quot;+
&quot;772042452452961268794654619316517468139267250410380254625965686914419287160829380&quot;+
&quot;317271436778265487756648508567407764845146443994046142260319309673540257444607030&quot;+
&quot;809608504748663852313818167675143866747664789088143714198549423151997354880375165&quot;+
&quot;861275352916610007105355824987941472950929311389715599820565439287170007218085761&quot;+
&quot;025236889213244971389320378439353088774825970171559107088236836275898425891853530&quot;+
&quot;243634214367061189236789192372314672321720534016492568727477823445353476481149418&quot;+
&quot;642386776774406069562657379600867076257199184734022651462837904883062033061144630&quot;+
&quot;073719489002743643965002580936519443041191150608094879306786515887090060520346842&quot;+
&quot;973619384128965255653968602219412292420757432175748909770675268711581705113700915&quot;+
&quot;894266547859596489065305846025866838294002283300538207400567705304678700184162404&quot;+
&quot;418833232798386349001563121889560650553151272199398332030751408426091479001265168&quot;+
&quot;243443893572472788205486271552741877243002489794540196187233980860831664811490930&quot;+
&quot;667519339312890431641370681397776498176974868903887789991296503619270710889264105&quot;+
&quot;230924783917373501229842420499568935992206602204654941510613&quot;);


        /** Euler's constant.
        * @param mc The required precision of the result.
        * @return 3.14159...
        * @since 2009-05-29
        */
        static public BigDecimal pi(final MathContext mc)
        {
                /* look it up if possible */
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if ( mc.getPrecision() &lt; PI.precision() )</span>
<span class="nc" id="L128">                        return PI.round(mc) ;</span>
                else
                {
                        /* Broadhurst &lt;a href=&quot;http://arxiv.org/abs/math/9803067&quot;&gt;arXiv:math/9803067&lt;/a&gt;
                        */
<span class="nc" id="L133">                        int[] a = {1,0,0,-1,-1,-1,0,0} ; </span>
<span class="nc" id="L134">                        BigDecimal S = broadhurstBBP(1,1,a,mc) ;</span>
<span class="nc" id="L135">                        return multiplyRound(S,8) ;</span>
                }
        } /* BigDecimalMath.pi */

        /** Euler-Mascheroni constant.
        * @param mc The required precision of the result.
        * @return 0.577...
        * @since 2009-08-13
        */
        static public BigDecimal gamma(MathContext mc)
        {
                /* look it up if possible */
<span class="nc bnc" id="L147" title="All 2 branches missed.">                if ( mc.getPrecision() &lt; GAMMA.precision() )</span>
<span class="nc" id="L148">                        return GAMMA.round(mc) ;</span>
                else
                {
<span class="nc" id="L151">                        double eps = prec2err(0.577, mc.getPrecision() ) ;</span>


                        /* Euler-Stieltjes as shown in Dilcher, Aequat Math 48 (1) (1994) 55-85
                        */
<span class="nc" id="L156">                        MathContext mcloc =  new MathContext(2+mc.getPrecision()) ;</span>
<span class="nc" id="L157">                        BigDecimal resul =  BigDecimal.ONE ;</span>
<span class="nc" id="L158">                        resul =  resul.add( log(2,mcloc) ) ;</span>
<span class="nc" id="L159">                        resul =  resul.subtract( log(3,mcloc) ) ;</span>

                        /* how many terms: zeta-1 falls as 1/2^(2n+1), so the
                        * terms drop faster than 1/2^(4n+2). Set 1/2^(4kmax+2) &lt; eps.
                        * Leading term zeta(3)/(4^1*3) is 0.017. Leading zeta(3) is 1.2. Log(2) is 0.7
                        */
<span class="nc" id="L165">                        int kmax = (int)((Math.log(eps/0.7)-2.)/4.) ;</span>
<span class="nc" id="L166">                        mcloc =  new MathContext( 1+err2prec(1.2,eps/kmax) ) ;</span>
<span class="nc" id="L167">                        for(int n=1; ; n++)</span>
                        {
                                /* zeta is close to 1. Division of zeta-1 through
                                * 4^n*(2n+1) means divion through roughly 2^(2n+1)
                                */
<span class="nc" id="L172">                                BigDecimal c = zeta(2*n+1,mcloc).subtract(BigDecimal.ONE) ;</span>
<span class="nc" id="L173">                                BigInteger fourn = new BigInteger(&quot;&quot;+(2*n+1)) ;</span>
<span class="nc" id="L174">                                fourn = fourn.shiftLeft(2*n) ;</span>
<span class="nc" id="L175">                                c = divideRound(c, fourn) ;</span>
<span class="nc" id="L176">                                resul = resul.subtract(c) ;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                                if ( c.doubleValue() &lt; 0.1*eps)</span>
<span class="nc" id="L178">                                        break;</span>
                        }
<span class="nc" id="L180">                        return resul.round(mc) ;</span>
                }

        } /* BigDecimalMath.gamma */


        /** The square root.
        * @param x the non-negative argument.
        * @param mc
        * @return the square root of the BigDecimal.
        * @since 2008-10-27
        */
        static public BigDecimal sqrt(final BigDecimal x, final MathContext mc)
        {
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L195">                        throw new ArithmeticException(&quot;negative argument &quot;+x.toString()+ &quot; of square root&quot;) ;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">                if ( x.abs().subtract( new BigDecimal(Math.pow(10.,-mc.getPrecision())) ).compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L197">                        return BigDecimalMath.scalePrec(BigDecimal.ZERO,mc) ;</span>
                /* start the computation from a double precision estimate */
<span class="nc" id="L199">                BigDecimal s = new BigDecimal( Math.sqrt(x.doubleValue()) ,mc) ;</span>
<span class="nc" id="L200">                final BigDecimal half = new BigDecimal(&quot;2&quot;) ;</span>

                /* increase the local accuracy by 2 digits */
<span class="nc" id="L203">                MathContext locmc = new MathContext(mc.getPrecision()+2,mc.getRoundingMode()) ;</span>

                /* relative accuracy requested is 10^(-precision) 
                */
<span class="nc" id="L207">                final double eps = Math.pow(10.0,-mc.getPrecision()) ;</span>
                for (;;)
                {
                        /* s = s -(s/2-x/2s); test correction s-x/s for being
                        * smaller than the precision requested. The relative correction is 1-x/s^2,
                        * (actually half of this, which we use for a little bit of additional protection).
                        */
<span class="nc bnc" id="L214" title="All 2 branches missed.">                        if ( Math.abs(BigDecimal.ONE.subtract(x.divide(s.pow(2,locmc),locmc)).doubleValue()) &lt; eps)</span>
<span class="nc" id="L215">                                break ;</span>
<span class="nc" id="L216">                        s = s.add(x.divide(s,locmc)).divide(half,locmc) ;</span>
                        /* debugging
                        * System.out.println(&quot;itr &quot;+x.round(locmc).toString() + &quot; &quot; + s.round(locmc).toString()) ;
                        */
                }
<span class="nc" id="L221">                return s ;</span>
        } /* BigDecimalMath.sqrt */

        /** The square root.
        * @param x the non-negative argument.
        * @return the square root of the BigDecimal rounded to the precision implied by x.
        * @since 2009-06-25
        */
        static public BigDecimal sqrt(final BigDecimal x)
        {
<span class="nc bnc" id="L231" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L232">                        throw new ArithmeticException(&quot;negative argument &quot;+x.toString()+ &quot; of square root&quot;) ;</span>

<span class="nc" id="L234">                return root(2,x) ;</span>
        } /* BigDecimalMath.sqrt */

        /** The cube root.
        * @param x The argument.
        * @return The cubic root of the BigDecimal rounded to the precision implied by x.
        * The sign of the result is the sign of the argument.
        * @since 2009-08-16
        */
        static public BigDecimal cbrt(final BigDecimal x)
        {
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L246">                        return root(3,x.negate()).negate() ;</span>
                else
<span class="nc" id="L248">                        return root(3,x) ;</span>
        } /* BigDecimalMath.cbrt */

        /** The integer root.
        * @param n the positive argument.
        * @param x the non-negative argument.
        * @return The n-th root of the BigDecimal rounded to the precision implied by x, x^(1/n).
        * @since 2009-07-30
        */
        static public BigDecimal root(final int n, final BigDecimal x)
        {
<span class="nc bnc" id="L259" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L260">                        throw new ArithmeticException(&quot;negative argument &quot;+x.toString()+ &quot; of root&quot;) ;</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                if ( n&lt;= 0 )</span>
<span class="nc" id="L262">                        throw new ArithmeticException(&quot;negative power &quot;+ n + &quot; of root&quot;) ;</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">                if ( n == 1 )</span>
<span class="nc" id="L265">                        return x ;</span>

                /* start the computation from a double precision estimate */
<span class="nc" id="L268">                BigDecimal s = new BigDecimal( Math.pow(x.doubleValue(),1.0/n) ) ;</span>

                /* this creates nth with nominal precision of 1 digit
                */
<span class="nc" id="L272">                final BigDecimal nth = new BigDecimal(n) ;</span>

                /* Specify an internal accuracy within the loop which is
                * slightly larger than what is demanded by 'eps' below.
                */
<span class="nc" id="L277">                final BigDecimal xhighpr = scalePrec(x,2) ;</span>
<span class="nc" id="L278">                MathContext mc = new MathContext( 2+x.precision() ) ;</span>

                /* Relative accuracy of the result is eps.
                */
<span class="nc" id="L282">                final double eps = x.ulp().doubleValue()/(2*n*x.doubleValue()) ;</span>
                for (;;)
                {
                        /* s = s -(s/n-x/n/s^(n-1)) = s-(s-x/s^(n-1))/n; test correction s/n-x/s for being
                        * smaller than the precision requested. The relative correction is (1-x/s^n)/n,
                        */
<span class="nc" id="L288">                        BigDecimal c = xhighpr.divide( s.pow(n-1),mc ) ;</span>
<span class="nc" id="L289">                        c = s.subtract(c) ;</span>
<span class="nc" id="L290">                        MathContext locmc = new MathContext( c.precision() ) ;</span>
<span class="nc" id="L291">                        c = c.divide(nth,locmc) ;</span>
<span class="nc" id="L292">                        s = s. subtract(c) ;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                        if ( Math.abs( c.doubleValue()/s.doubleValue()) &lt; eps)</span>
<span class="nc" id="L294">                                break ;</span>
<span class="nc" id="L295">                }</span>
<span class="nc" id="L296">                return s.round(new MathContext( err2prec(eps)) ) ;</span>
        } /* BigDecimalMath.root */

        /** The hypotenuse.
        * @param x the first argument.
        * @param y the second argument.
        * @return the square root of the sum of the squares of the two arguments, sqrt(x^2+y^2).
        * @since 2009-06-25
        */
        static public BigDecimal hypot(final BigDecimal x, final BigDecimal y)
        {
                /* compute x^2+y^2
                */
<span class="nc" id="L309">                BigDecimal z = x.pow(2).add(y.pow(2)) ;</span>

                /* truncate to the precision set by x and y. Absolute error = 2*x*xerr+2*y*yerr,
                * where the two errors are 1/2 of the ulp's.  Two intermediate protectio digits.
                */
<span class="nc" id="L314">                BigDecimal zerr = x.abs().multiply(x.ulp()).add(y.abs().multiply(y.ulp())) ;</span>
<span class="nc" id="L315">                MathContext mc = new MathContext(  2+err2prec(z,zerr) ) ;</span>

                /* Pull square root */
<span class="nc" id="L318">                z = sqrt(z.round(mc)) ;</span>

                /* Final rounding. Absolute error in the square root is (y*yerr+x*xerr)/z, where zerr holds 2*(x*xerr+y*yerr).
                */
<span class="nc" id="L322">                mc = new MathContext(  err2prec(z.doubleValue() ,0.5*zerr.doubleValue() /z.doubleValue() ) ) ;</span>
<span class="nc" id="L323">                return z.round(mc) ;</span>
        } /* BigDecimalMath.hypot */

        /** The hypotenuse.
        * @param n the first argument.
        * @param x the second argument.
        * @return the square root of the sum of the squares of the two arguments, sqrt(n^2+x^2).
        * @since 2009-08-05
        */
        static public BigDecimal hypot(final int n, final BigDecimal x)
        {
                /* compute n^2+x^2 in infinite precision
                */
<span class="nc" id="L336">                BigDecimal z = (new BigDecimal(n)).pow(2).add(x.pow(2)) ;</span>

                /* Truncate to the precision set by x. Absolute error = in z (square of the result) is |2*x*xerr|,
                * where the error is 1/2 of the ulp. Two intermediate protection digits.
                * zerr is a signed value, but used only in conjunction with err2prec(), so this feature does not harm. 
                */
<span class="nc" id="L342">                double zerr = x.doubleValue()*x.ulp().doubleValue() ;</span>
<span class="nc" id="L343">                MathContext mc = new MathContext(  2+err2prec(z.doubleValue(),zerr) ) ;</span>

                /* Pull square root */
<span class="nc" id="L346">                z = sqrt(z.round(mc)) ;</span>

                /* Final rounding. Absolute error in the square root is x*xerr/z, where zerr holds 2*x*xerr.
                */
<span class="nc" id="L350">                mc = new MathContext(  err2prec(z.doubleValue(),0.5*zerr/z.doubleValue() ) ) ;</span>
<span class="nc" id="L351">                return z.round(mc) ;</span>
        } /* BigDecimalMath.hypot */


        /** A suggestion for the maximum numter of terms in the Taylor expansion of the exponential.
        */
<span class="nc" id="L357">        static private int TAYLOR_NTERM = 8 ;</span>

        /** The exponential function.
        * @param x the argument.
        * @return exp(x).
        * The precision of the result is implicitly defined by the precision in the argument.
        * In particular this means that &quot;Invalid Operation&quot; errors are thrown if catastrophic
        * cancellation of digits causes the result to have no valid digits left.
        * @since 2009-05-29
        * @author Richard J. Mathar
        */
        static public BigDecimal exp(BigDecimal x)
        {
                /* To calculate the value if x is negative, use exp(-x) = 1/exp(x)
                */
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
                {
<span class="nc" id="L374">                        final BigDecimal invx = exp(x.negate() ) ;</span>
                        /* Relative error in inverse of invx is the same as the relative errror in invx.
                        * This is used to define the precision of the result.
                        */
<span class="nc" id="L378">                        MathContext mc = new MathContext( invx.precision() ) ;</span>
<span class="nc" id="L379">                        return BigDecimal.ONE.divide( invx, mc ) ;</span>
                }
<span class="nc bnc" id="L381" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
                {
                        /* recover the valid number of digits from x.ulp(), if x hits the
                        * zero. The x.precision() is 1 then, and does not provide this information.
                        */
<span class="nc" id="L386">                        return scalePrec(BigDecimal.ONE, -(int)(Math.log10( x.ulp().doubleValue() )) ) ;</span>
                }
                else
                {
                        /* Push the number in the Taylor expansion down to a small
                        * value where TAYLOR_NTERM terms will do. If x&lt;1, the n-th term is of the order
                        * x^n/n!, and equal to both the absolute and relative error of the result
                        * since the result is close to 1. The x.ulp() sets the relative and absolute error
                        * of the result, as estimated from the first Taylor term.
                        * We want x^TAYLOR_NTERM/TAYLOR_NTERM! &lt; x.ulp, which is guaranteed if
                        * x^TAYLOR_NTERM &lt; TAYLOR_NTERM*(TAYLOR_NTERM-1)*...*x.ulp.
                        */
<span class="nc" id="L398">                        final double xDbl = x.doubleValue() ;</span>
<span class="nc" id="L399">                        final double xUlpDbl = x.ulp().doubleValue() ;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                        if ( Math.pow(xDbl,TAYLOR_NTERM) &lt; TAYLOR_NTERM*(TAYLOR_NTERM-1.0)*(TAYLOR_NTERM-2.0)*xUlpDbl ) </span>
                        {
                                /* Add TAYLOR_NTERM terms of the Taylor expansion (Euler's sum formula)
                                */
<span class="nc" id="L404">                                BigDecimal resul = BigDecimal.ONE ;</span>

                                /* x^i */
<span class="nc" id="L407">                                BigDecimal xpowi = BigDecimal.ONE ;</span>

                                /* i factorial */
<span class="nc" id="L410">                                BigInteger ifac = BigInteger.ONE ;</span>

                                /* TAYLOR_NTERM terms to be added means we move x.ulp() to the right
                                * for each power of 10 in TAYLOR_NTERM, so the addition won't add noise beyond
                                * what's already in x.
                                */
<span class="nc" id="L416">                                MathContext mcTay = new MathContext( err2prec(1.,xUlpDbl/TAYLOR_NTERM) ) ;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                                for(int i=1 ; i &lt;= TAYLOR_NTERM ; i++)</span>
                                {
<span class="nc" id="L419">                                        ifac = ifac.multiply(new BigInteger(&quot;&quot;+i) ) ;</span>
<span class="nc" id="L420">                                        xpowi = xpowi.multiply(x) ;</span>
<span class="nc" id="L421">                                        final BigDecimal c= xpowi.divide(new BigDecimal(ifac),mcTay)  ;</span>
<span class="nc" id="L422">                                        resul = resul.add(c) ;</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">                                        if ( Math.abs(xpowi.doubleValue()) &lt; i &amp;&amp; Math.abs(c.doubleValue()) &lt; 0.5* xUlpDbl )</span>
<span class="nc" id="L424">                                                break;</span>
                                }
                                /* exp(x+deltax) = exp(x)(1+deltax) if deltax is &lt;&lt;1. So the relative error
                                * in the result equals the absolute error in the argument.
                                */
<span class="nc" id="L429">                                MathContext mc = new MathContext( err2prec(xUlpDbl/2.) ) ;</span>
<span class="nc" id="L430">                                return resul.round(mc) ;</span>
                        }
                        else
                        {
                                /* Compute exp(x) = (exp(0.1*x))^10. Division by 10 does not lead
                                * to loss of accuracy.
                                */
<span class="nc" id="L437">                                int exSc = (int) ( 1.0-Math.log10( TAYLOR_NTERM*(TAYLOR_NTERM-1.0)*(TAYLOR_NTERM-2.0)*xUlpDbl</span>
<span class="nc" id="L438">                                                        /Math.pow(xDbl,TAYLOR_NTERM) ) / ( TAYLOR_NTERM-1.0) ) ; </span>
<span class="nc" id="L439">                                BigDecimal xby10 = x.scaleByPowerOfTen(-exSc) ;</span>
<span class="nc" id="L440">                                BigDecimal expxby10 = exp(xby10) ;</span>

                                /* Final powering by 10 means that the relative error of the result
                                * is 10 times the relative error of the base (First order binomial expansion).
                                * This looses one digit.
                                */
<span class="nc" id="L446">                                MathContext mc = new MathContext( expxby10.precision()-exSc ) ;</span>
                                /* Rescaling the powers of 10 is done in chunks of a maximum of 8 to avoid an invalid operation
                                * response by the BigDecimal.pow library or integer overflow.
                                */
<span class="nc bnc" id="L450" title="All 2 branches missed.">                                while ( exSc &gt; 0 )</span>
                                {
<span class="nc" id="L452">                                        int exsub = Math.min(8,exSc) ;</span>
<span class="nc" id="L453">                                        exSc -= exsub ;</span>
<span class="nc" id="L454">                                        MathContext mctmp = new MathContext( expxby10.precision()-exsub+2 ) ;</span>
<span class="nc" id="L455">                                        int pex = 1 ;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                                        while ( exsub-- &gt; 0 )</span>
<span class="nc" id="L457">                                                pex *= 10 ;</span>
<span class="nc" id="L458">                                        expxby10 = expxby10.pow(pex,mctmp) ;</span>
<span class="nc" id="L459">                                }</span>
<span class="nc" id="L460">                                return expxby10.round(mc) ;</span>
                        }
                }
        } /* BigDecimalMath.exp */

        /** The base of the natural logarithm.
        * @param mc the required precision of the result
        * @return exp(1) = 2.71828....
        * @since 2009-05-29
        */
        static public BigDecimal exp(final MathContext mc)
        {
                /* look it up if possible */
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if ( mc.getPrecision() &lt; E.precision() )</span>
<span class="nc" id="L474">                        return E.round(mc) ;</span>
                else
                {
                        /* Instantiate a 1.0 with the requested pseudo-accuracy
                        * and delegate the computation to the public method above.
                        */
<span class="nc" id="L480">                        BigDecimal uni = scalePrec(BigDecimal.ONE, mc.getPrecision() ) ;</span>
<span class="nc" id="L481">                        return exp(uni) ;</span>
                }
        } /* BigDecimalMath.exp */

        /** The natural logarithm.
        * @param x the argument.
        * @return ln(x).
        * The precision of the result is implicitly defined by the precision in the argument.
        * @since 2009-05-29
        * @author Richard J. Mathar
        */
        static public BigDecimal log(BigDecimal x)
        {
                /* the value is undefined if x is negative.
                */
<span class="nc bnc" id="L496" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L497">                        throw new ArithmeticException(&quot;Cannot take log of negative &quot;+ x.toString() ) ;</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ONE) == 0 )</span>
                {
                        /* log 1. = 0. */
<span class="nc" id="L501">                        return scalePrec(BigDecimal.ZERO, x.precision()-1) ;</span>
                }
<span class="nc bnc" id="L503" title="All 2 branches missed.">                else if ( Math.abs(x.doubleValue()-1.0) &lt;= 0.3 )</span>
                {
                        /* The standard Taylor series around x=1, z=0, z=x-1. Abramowitz-Stegun 4.124.
                        * The absolute error is err(z)/(1+z) = err(x)/x.
                        */
<span class="nc" id="L508">                        BigDecimal z = scalePrec(x.subtract(BigDecimal.ONE),2) ;</span>
<span class="nc" id="L509">                        BigDecimal zpown = z ;</span>
<span class="nc" id="L510">                        double eps = 0.5*x.ulp().doubleValue()/Math.abs(x.doubleValue()) ;</span>
<span class="nc" id="L511">                        BigDecimal resul = z ;</span>
<span class="nc" id="L512">                        for(int k= 2;; k++)</span>
                        {
<span class="nc" id="L514">                                zpown = multiplyRound(zpown,z) ;</span>
<span class="nc" id="L515">                                BigDecimal c = divideRound(zpown,k) ;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">                                if ( k % 2 == 0)</span>
<span class="nc" id="L517">                                        resul = resul.subtract(c) ;</span>
                                else
<span class="nc" id="L519">                                        resul = resul.add(c) ;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                                if ( Math.abs(c.doubleValue()) &lt; eps)</span>
<span class="nc" id="L521">                                        break;</span>
                        }
<span class="nc" id="L523">                        MathContext mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L524">                        return resul.round(mc) ;</span>
                }
                else
                {
<span class="nc" id="L528">                        final double xDbl = x.doubleValue() ;</span>
<span class="nc" id="L529">                        final double xUlpDbl = x.ulp().doubleValue() ;</span>

                        /* Map log(x) = log root[r](x)^r = r*log( root[r](x)) with the aim
                        * to move roor[r](x) near to 1.2 (that is, below the 0.3 appearing above), where log(1.2) is roughly 0.2.
                        */
<span class="nc" id="L534">                        int r = (int) (Math.log(xDbl)/0.2) ;</span>

                        /* Since the actual requirement is a function of the value 0.3 appearing above,
                        * we avoid the hypothetical case of endless recurrence by ensuring that r &gt;= 2.
                        */
<span class="nc" id="L539">                        r = Math.max(2,r) ;</span>

                        /* Compute r-th root with 2 additional digits of precision
                        */
<span class="nc" id="L543">                        BigDecimal xhighpr = scalePrec(x,2) ;</span>
<span class="nc" id="L544">                        BigDecimal resul = root(r,xhighpr) ;</span>
<span class="nc" id="L545">                        resul = log(resul).multiply(new BigDecimal(r)) ;</span>

                        /* error propagation: log(x+errx) = log(x)+errx/x, so the absolute error
                        * in the result equals the relative error in the input, xUlpDbl/xDbl .
                        */
<span class="nc" id="L550">                        MathContext mc = new MathContext( err2prec(resul.doubleValue(),xUlpDbl/xDbl) ) ;</span>
<span class="nc" id="L551">                        return resul.round(mc) ;</span>
                }
        } /* BigDecimalMath.log */

        /** The natural logarithm.
        * @param n The main argument, a strictly positive integer.
        * @param mc The requirements on the precision.
        * @return ln(n).
        * @since 2009-08-08
        * @author Richard J. Mathar
        */
        static public BigDecimal log(int n, final MathContext mc)
        {
                /* the value is undefined if x is negative.
                */
<span class="nc bnc" id="L566" title="All 2 branches missed.">                if ( n &lt;= 0 )</span>
<span class="nc" id="L567">                        throw new ArithmeticException(&quot;Cannot take log of negative &quot;+ n ) ;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                else if ( n == 1)</span>
<span class="nc" id="L569">                        return BigDecimal.ZERO ;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                else if ( n == 2)</span>
                {
<span class="nc bnc" id="L572" title="All 2 branches missed.">                        if ( mc.getPrecision() &lt; LOG2.precision() )</span>
<span class="nc" id="L573">                                return LOG2.round(mc) ;</span>
                        else
                        {
                                /* Broadhurst &lt;a href=&quot;http://arxiv.org/abs/math/9803067&quot;&gt;arXiv:math/9803067&lt;/a&gt;
                                * Error propagation: the error in log(2) is twice the error in S(2,-5,...).
                                */
<span class="nc" id="L579">                                int[] a = {2,-5,-2,-7,-2,-5,2,-3} ; </span>
<span class="nc" id="L580">                                BigDecimal S = broadhurstBBP(2,1,a, new MathContext(1+mc.getPrecision()) ) ;</span>
<span class="nc" id="L581">                                S = S.multiply(new BigDecimal(8)) ;</span>
<span class="nc" id="L582">                                S = sqrt(divideRound(S,3)) ;</span>
<span class="nc" id="L583">                                return S.round(mc) ;</span>
                        }
                }
<span class="nc bnc" id="L586" title="All 2 branches missed.">                else if ( n == 3)</span>
                {
                        /* summation of a series roughly proportional to (7/500)^k. Estimate count
                        * of terms to estimate the precision (drop the favorable additional
                        * 1/k here): 0.013^k &lt;= 10^(-precision), so k*log10(0.013) &lt;= -precision
                        * so k&gt;= precision/1.87.
                        */
<span class="nc" id="L593">                        int kmax = (int)(mc.getPrecision()/1.87) ;</span>
<span class="nc" id="L594">                        MathContext mcloc = new MathContext( mc.getPrecision()+ 1+(int)(Math.log10(kmax*0.693/1.098)) ) ;</span>
<span class="nc" id="L595">                        BigDecimal log3 = multiplyRound( log(2,mcloc),19 ) ;</span>

                        /* log3 is roughly 1, so absolute and relative error are the same. The
                        * result will be divided by 12, so a conservative error is the one
                        * already found in mc
                        */
<span class="nc" id="L601">                        double eps = prec2err(1.098,mc.getPrecision() )/kmax ;</span>
<span class="nc" id="L602">                        Rational r = new Rational(7153,524288) ;</span>
<span class="nc" id="L603">                        Rational pk = new Rational(7153,524288) ;</span>
<span class="nc" id="L604">                        for(int k=1; ; k++)</span>
                        {
<span class="nc" id="L606">                                Rational tmp = pk.divide(k) ;</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                                if ( tmp.doubleValue() &lt; eps)</span>
<span class="nc" id="L608">                                        break ;</span>

                                /* how many digits of tmp do we need in the sum?
                                */
<span class="nc" id="L612">                                mcloc = new MathContext( err2prec(tmp.doubleValue(),eps) ) ;</span>
<span class="nc" id="L613">                                BigDecimal c = pk.divide(k).BigDecimalValue(mcloc) ;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                                if ( k % 2 != 0)</span>
<span class="nc" id="L615">                                        log3 = log3.add(c) ;</span>
                                else
<span class="nc" id="L617">                                        log3 = log3.subtract(c) ;</span>
<span class="nc" id="L618">                                pk = pk.multiply(r) ;</span>
                        }
<span class="nc" id="L620">                        log3 = divideRound( log3,12 ) ;</span>
<span class="nc" id="L621">                        return log3.round(mc) ;</span>
                }
<span class="nc bnc" id="L623" title="All 2 branches missed.">                else if ( n == 5)</span>
                {
                        /* summation of a series roughly proportional to (7/160)^k. Estimate count
                        * of terms to estimate the precision (drop the favorable additional
                        * 1/k here): 0.046^k &lt;= 10^(-precision), so k*log10(0.046) &lt;= -precision
                        * so k&gt;= precision/1.33.
                        */
<span class="nc" id="L630">                        int kmax = (int)(mc.getPrecision()/1.33) ;</span>
<span class="nc" id="L631">                        MathContext mcloc = new MathContext( mc.getPrecision()+ 1+(int)(Math.log10(kmax*0.693/1.609)) ) ;</span>
<span class="nc" id="L632">                        BigDecimal log5 = multiplyRound( log(2,mcloc),14 ) ;</span>

                        /* log5 is roughly 1.6, so absolute and relative error are the same. The
                        * result will be divided by 6, so a conservative error is the one
                        * already found in mc
                        */
<span class="nc" id="L638">                        double eps = prec2err(1.6,mc.getPrecision() )/kmax ;</span>
<span class="nc" id="L639">                        Rational r = new Rational(759,16384) ;</span>
<span class="nc" id="L640">                        Rational pk = new Rational(759,16384) ;</span>
<span class="nc" id="L641">                        for(int k=1; ; k++)</span>
                        {
<span class="nc" id="L643">                                Rational tmp = pk.divide(k) ;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                                if ( tmp.doubleValue() &lt; eps)</span>
<span class="nc" id="L645">                                        break ;</span>

                                /* how many digits of tmp do we need in the sum?
                                */
<span class="nc" id="L649">                                mcloc = new MathContext( err2prec(tmp.doubleValue(),eps) ) ;</span>
<span class="nc" id="L650">                                BigDecimal c = pk.divide(k).BigDecimalValue(mcloc) ;</span>
<span class="nc" id="L651">                                log5 = log5.subtract(c) ;</span>
<span class="nc" id="L652">                                pk = pk.multiply(r) ;</span>
                        }
<span class="nc" id="L654">                        log5 = divideRound( log5,6 ) ;</span>
<span class="nc" id="L655">                        return log5.round(mc) ;</span>
                }
<span class="nc bnc" id="L657" title="All 2 branches missed.">                else if ( n == 7)</span>
                {
                        /* summation of a series roughly proportional to (1/8)^k. Estimate count
                        * of terms to estimate the precision (drop the favorable additional
                        * 1/k here): 0.125^k &lt;= 10^(-precision), so k*log10(0.125) &lt;= -precision
                        * so k&gt;= precision/0.903.
                        */
<span class="nc" id="L664">                        int kmax = (int)(mc.getPrecision()/0.903) ;</span>
<span class="nc" id="L665">                        MathContext mcloc = new MathContext( mc.getPrecision()+ 1+(int)(Math.log10(kmax*3*0.693/1.098)) ) ;</span>
<span class="nc" id="L666">                        BigDecimal log7 = multiplyRound( log(2,mcloc),3 ) ;</span>

                        /* log7 is roughly 1.9, so absolute and relative error are the same.
                        */
<span class="nc" id="L670">                        double eps = prec2err(1.9,mc.getPrecision() )/kmax ;</span>
<span class="nc" id="L671">                        Rational r = new Rational(1,8) ;</span>
<span class="nc" id="L672">                        Rational pk = new Rational(1,8) ;</span>
<span class="nc" id="L673">                        for(int k=1; ; k++)</span>
                        {
<span class="nc" id="L675">                                Rational tmp = pk.divide(k) ;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                                if ( tmp.doubleValue() &lt; eps)</span>
<span class="nc" id="L677">                                        break ;</span>

                                /* how many digits of tmp do we need in the sum?
                                */
<span class="nc" id="L681">                                mcloc = new MathContext( err2prec(tmp.doubleValue(),eps) ) ;</span>
<span class="nc" id="L682">                                BigDecimal c = pk.divide(k).BigDecimalValue(mcloc) ;</span>
<span class="nc" id="L683">                                log7 = log7.subtract(c) ;</span>
<span class="nc" id="L684">                                pk = pk.multiply(r) ;</span>
                        }
<span class="nc" id="L686">                        return log7.round(mc) ;</span>

                }

                else
                {
                        /* At this point one could either forward to the log(BigDecimal) signature (implemented)
                        * or decompose n into Ifactors and use an implemenation of all the prime bases.
                        * Estimate of the result; convert the mc argument to an  absolute error eps
                        * log(n+errn) = log(n)+errn/n = log(n)+eps
                        */
<span class="nc" id="L697">                        double res = Math.log((double)n) ;</span>
<span class="nc" id="L698">                        double eps = prec2err(res,mc.getPrecision() ) ;</span>
                        /* errn = eps*n, convert absolute error in result to requirement on absolute error in input
                        */
<span class="nc" id="L701">                        eps *= n ;</span>
                        /* Convert this absolute requirement of error in n to a relative error in n
                        */
<span class="nc" id="L704">                        final MathContext mcloc = new MathContext( 1+err2prec((double)n,eps ) ) ;</span>
                        /* Padd n with a number of zeros to trigger the required accuracy in
                        * the standard signature method
                        */
<span class="nc" id="L708">                        BigDecimal nb = scalePrec(new BigDecimal(n),mcloc) ;</span>
<span class="nc" id="L709">                        return log(nb) ;</span>
                }
        } /* log */

        /** The natural logarithm.
        * @param r The main argument, a strictly positive value.
        * @param mc The requirements on the precision.
        * @return ln(r).
        * @since 2009-08-09
        * @author Richard J. Mathar
        */
        static public BigDecimal log(final Rational r, final MathContext mc)
        {
                /* the value is undefined if x is negative.
                */
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if ( r.compareTo(Rational.ZERO) &lt;= 0 )</span>
<span class="nc" id="L725">                        throw new ArithmeticException(&quot;Cannot take log of negative &quot;+ r.toString() ) ;</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                else if ( r.compareTo(Rational.ONE) == 0)</span>
<span class="nc" id="L727">                        return BigDecimal.ZERO ;</span>
                else
                {

                        /* log(r+epsr) = log(r)+epsr/r. Convert the precision to an absolute error in the result.
                        * eps contains the required absolute error of the result, epsr/r.
                        */
<span class="nc" id="L734">                        double eps = prec2err( Math.log(r.doubleValue()), mc.getPrecision()) ;</span>

                        /* Convert this further into a requirement of the relative precision in r, given that
                        * epsr/r is also the relative precision of r. Add one safety digit.
                        */
<span class="nc" id="L739">                        MathContext mcloc = new MathContext( 1+err2prec(eps)  ) ;</span>

<span class="nc" id="L741">                        final BigDecimal resul = log( r.BigDecimalValue(mcloc) );</span>

<span class="nc" id="L743">                        return resul.round(mc) ;</span>
                }
        } /* log */

        /** Power function.
        * @param x Base of the power.
        * @param y Exponent of the power.
        * @return x^y.
        *  The estimation of the relative error in the result is |log(x)*err(y)|+|y*err(x)/x|
        * @since 2009-06-01
        */
        static public BigDecimal pow(final BigDecimal x, final BigDecimal y)
        {
<span class="nc bnc" id="L756" title="All 2 branches missed.">                if( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L757">                        throw new ArithmeticException(&quot;Cannot power negative &quot;+ x.toString()) ;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                else if( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L759">                        return BigDecimal.ZERO ;</span>
                else
                {
                        /* return x^y = exp(y*log(x)) ;
                        */
<span class="nc" id="L764">                        BigDecimal logx = log(x) ;</span>
<span class="nc" id="L765">                        BigDecimal ylogx = y.multiply(logx) ;</span>
<span class="nc" id="L766">                        BigDecimal resul = exp(ylogx) ;</span>

                        /* The estimation of the relative error in the result is |log(x)*err(y)|+|y*err(x)/x| 
                        */
<span class="nc" id="L770">                        double errR = Math.abs(logx.doubleValue()*y.ulp().doubleValue()/2.)</span>
<span class="nc" id="L771">                                + Math.abs(y.doubleValue()*x.ulp().doubleValue()/2./x.doubleValue()) ;</span>
<span class="nc" id="L772">                        MathContext mcR = new MathContext( err2prec(1.0,errR) ) ;</span>
<span class="nc" id="L773">                        return resul.round(mcR) ;</span>
                }
        } /* BigDecimalMath.pow */

        /** Raise to an integer power and round.
        * @param x The base.
        * @param n The exponent.
        * @return x^n.
        * @since 2009-08-13
        * @since 2010-05-26 handle also n&lt;0 cases.
        */
        static public BigDecimal powRound(final BigDecimal x, final int n)
        {
                /** Special cases: x^1=x and x^0 = 1
                */
<span class="nc bnc" id="L788" title="All 2 branches missed.">                if ( n == 1 )</span>
<span class="nc" id="L789">                        return x;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">                else if ( n == 0 )</span>
<span class="nc" id="L791">                        return BigDecimal.ONE ;</span>
                else
                {
                        /* The relative error in the result is n times the relative error in the input.
                        * The estimation is slightly optimistic due to the integer rounding of the logarithm.
                        * Since the standard BigDecimal.pow can only handle positive n, we split the algorithm.
                        */
<span class="nc" id="L798">                        MathContext mc = new MathContext( x.precision() - (int)Math.log10((double)(Math.abs(n))) ) ;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                        if ( n &gt; 0 )</span>
<span class="nc" id="L800">                                return x.pow(n,mc) ;</span>
                        else
<span class="nc" id="L802">                                return BigDecimal.ONE.divide( x.pow(-n),mc) ;</span>
                }
        } /* BigDecimalMath.powRound */

        /** Raise to an integer power and round.
        * @param x The base.
        * @param n The exponent.
        *   The current implementation allows n only in the interval of the standard int values.
        * @return x^n.
        * @since 2010-05-26
        */
        static public BigDecimal powRound(final BigDecimal x, final BigInteger n)
        {
                /** For now, the implementation forwards to the cases where n
                * is in the range of the standard integers. This might, however, be
                * implemented to decompose larger powers into cascaded calls to smaller ones.
                */
<span class="nc bnc" id="L819" title="All 4 branches missed.">                if ( n.compareTo(Rational.MAX_INT) &gt; 0 || n.compareTo(Rational.MIN_INT) &lt; 0)</span>
<span class="nc" id="L820">                        throw new ProviderException(&quot;Not implemented: big power &quot;+n.toString() ) ;</span>
                else 
<span class="nc" id="L822">                        return powRound(x,n.intValue() ) ;</span>
        } /* BigDecimalMath.powRound */

        /** Raise to a fractional power and round.
        * @param x The base.
        *     Generally enforced to be positive, with the exception of integer exponents where
        *     the sign is carried over according to the parity of the exponent.
        * @param q The exponent.
        * @return x^q.
        * @since 2010-05-26
        */
        static public BigDecimal powRound(final BigDecimal x, final Rational q)
        {
                /** Special cases: x^1=x and x^0 = 1
                */
<span class="nc bnc" id="L837" title="All 2 branches missed.">                if ( q.compareTo(BigInteger.ONE) == 0 )</span>
<span class="nc" id="L838">                        return x;</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                else if ( q.signum() == 0 )</span>
<span class="nc" id="L840">                        return BigDecimal.ONE ;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">                else if ( q.isInteger() )</span>
                {
                        /* We are sure that the denominator is positive here, because normalize() has been
                        * called during constrution etc.
                        */
<span class="nc" id="L846">                                return powRound(x,q.a) ;</span>
                }
                        /* Refuse to operate on the general negative basis. The integer q have already been handled above.
                        */
<span class="nc bnc" id="L850" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L851">                        throw new ArithmeticException(&quot;Cannot power negative &quot;+ x.toString() ) ;</span>
                else
                {
<span class="nc bnc" id="L854" title="All 2 branches missed.">                        if ( q.isIntegerFrac() )</span>
                        {
                                /* Newton method with first estimate in double precision.
                                * The disadvantage of this first line here is that the result must fit in the
                                * standard range of double precision numbers exponents.
                                */
<span class="nc" id="L860">                                double estim = Math.pow( x.doubleValue(),q.doubleValue() ) ;</span>
<span class="nc" id="L861">                                BigDecimal res = new BigDecimal(estim) ;</span>

                                /* The error in x^q is q*x^(q-1)*Delta(x).
                                * The relative error is q*Delta(x)/x, q times the relative error of x.
                                */
<span class="nc" id="L866">                                BigDecimal reserr = new BigDecimal( 0.5* q.abs().doubleValue() </span>
<span class="nc" id="L867">                                                                * x.ulp().divide(x.abs(),MathContext.DECIMAL64).doubleValue() ) ;</span>

                                /* The main point in branching the cases above is that this conversion
                                * will succeed for numerator and denominator of q.
                                */
<span class="nc" id="L872">                                int qa = q.a.intValue() ;</span>
<span class="nc" id="L873">                                int qb = q.b.intValue() ;</span>

                                /* Newton iterations. */
<span class="nc" id="L876">                                BigDecimal xpowa = powRound(x, qa) ;</span>
                                for( ;; )
                                {
                                        /* numerator and denominator of the Newton term.  The major
                                        * disadvantage of this implementation is that the updates of the powers
                                        * of the new estimate are done in full precision calling BigDecimal.pow(),
                                        * which becomes slow if the denominator of q is large.
                                        */
<span class="nc" id="L884">                                        BigDecimal nu = res.pow(qb) .subtract(xpowa) ;</span>
<span class="nc" id="L885">                                        BigDecimal de = multiplyRound( res.pow(qb-1),q.b) ;</span>

                                        /* estimated correction */
<span class="nc" id="L888">                                        BigDecimal eps = nu.divide(de,MathContext.DECIMAL64) ;</span>

<span class="nc" id="L890">                                        BigDecimal err = res.multiply(reserr,MathContext.DECIMAL64) ;</span>
<span class="nc" id="L891">                                        int precDiv = 2+err2prec(eps,err) ;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">                                        if ( precDiv &lt;= 0 )</span>
                                        {
                                                /* The case when the precision is already reached and any precision
                                                * will do. */
<span class="nc" id="L896">                                                eps = nu.divide(de,MathContext.DECIMAL32) ;</span>
                                        }
                                        else
                                        {
<span class="nc" id="L900">                                                MathContext mc = new MathContext(precDiv) ;</span>
<span class="nc" id="L901">                                                eps = nu.divide(de,mc) ;</span>
                                        }

<span class="nc" id="L904">                                        res = subtractRound(res,eps) ;</span>
                                        /* reached final precision if the relative error fell below reserr,
                                        * |eps/res| &lt; reserr
                                        */
<span class="nc bnc" id="L908" title="All 2 branches missed.">                                        if ( eps.divide(res,MathContext.DECIMAL64).abs().compareTo(reserr) &lt; 0 )</span>
                                        {
                                                /* delete the bits of extra precision kept in this
                                                * working copy.
                                                */
<span class="nc" id="L913">                                                MathContext mc = new MathContext(err2prec(reserr.doubleValue())) ;</span>
<span class="nc" id="L914">                                                return res.round(mc) ;</span>
                                        }
<span class="nc" id="L916">                                }</span>
                        }
                        else
                        {
                                /* The error in x^q is q*x^(q-1)*Delta(x) + Delta(q)*x^q*log(x).
                                * The relative error is q/x*Delta(x) + Delta(q)*log(x). Convert q to a floating point
                                * number such that its relative error becomes negligible: Delta(q)/q &lt;&lt; Delta(x)/x/log(x) .
                                */
<span class="nc" id="L924">                                int precq =  3+err2prec( (x.ulp().divide(x,MathContext.DECIMAL64)).doubleValue() </span>
<span class="nc" id="L925">                                                        / Math.log(x.doubleValue()) ) ;</span>
<span class="nc" id="L926">                                MathContext mc = new MathContext(precq) ;</span>

                                /* Perform the actual calculation as exponentiation of two floating point numbers.
                                */
<span class="nc" id="L930">                                return pow(x, q.BigDecimalValue(mc) ) ;</span>
                        }


                }
        } /* BigDecimalMath.powRound */

        /** Trigonometric sine.
        * @param x The argument in radians.
        * @return sin(x) in the range -1 to 1.
        * @since 2009-06-01
        */
        static public BigDecimal sin(final BigDecimal x)
        {
<span class="nc bnc" id="L944" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0)</span>
<span class="nc" id="L945">                        return sin(x.negate()).negate() ;</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L947">                        return BigDecimal.ZERO ;</span>
                else
                {
                        /* reduce modulo 2pi
                        */
<span class="nc" id="L952">                        BigDecimal res = mod2pi(x) ;</span>
<span class="nc" id="L953">                        double errpi = 0.5*Math.abs(x.ulp().doubleValue()) ;</span>
<span class="nc" id="L954">                        MathContext mc = new MathContext( 2+err2prec(3.14159,errpi) ) ;</span>
<span class="nc" id="L955">                        BigDecimal p= pi(mc) ;</span>
<span class="nc" id="L956">                        mc = new MathContext( x.precision() ) ;</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">                        if ( res.compareTo(p) &gt; 0 )</span>
                        {
                                /* pi&lt;x&lt;=2pi: sin(x)= - sin(x-pi)
                                */
<span class="nc" id="L961">                                return sin(subtractRound(res,p)) .negate() ;</span>
                        }
<span class="nc bnc" id="L963" title="All 2 branches missed.">                        else if ( res.multiply(new BigDecimal(&quot;2&quot;)).compareTo(p) &gt; 0 )</span>
                        {
                                /* pi/2&lt;x&lt;=pi: sin(x)= sin(pi-x)
                                */
<span class="nc" id="L967">                                return sin(subtractRound(p,res)) ;</span>
                        }
                        else
                        {
                                /* for the range 0&lt;=x&lt;Pi/2 one could use sin(2x)=2sin(x)cos(x)
                                * to split this further. Here, use the sine up to pi/4 and the cosine higher up.
                                */
<span class="nc bnc" id="L974" title="All 2 branches missed.">                                if ( res.multiply(new BigDecimal(&quot;4&quot;)).compareTo(p) &gt; 0 )</span>
                                {
                                        /* x&gt;pi/4: sin(x) = cos(pi/2-x)
                                        */
<span class="nc" id="L978">                                        return cos( subtractRound(p.divide(new BigDecimal(&quot;2&quot;)),res) ) ;</span>
                                }
                                else
                                {
                                        /* Simple Taylor expansion, sum_{i=1..infinity} (-1)^(..)res^(2i+1)/(2i+1)! */
<span class="nc" id="L983">                                        BigDecimal resul = res ;</span>

                                        /* x^i */
<span class="nc" id="L986">                                        BigDecimal xpowi = res ;</span>

                                        /* 2i+1 factorial */
<span class="nc" id="L989">                                        BigInteger ifac = BigInteger.ONE ;</span>

                                        /* The error in the result is set by the error in x itself.
                                        */
<span class="nc" id="L993">                                        double xUlpDbl = res.ulp().doubleValue() ;</span>

                                        /* The error in the result is set by the error in x itself.
                                        * We need at most k terms to squeeze x^(2k+1)/(2k+1)! below this value.
                                        * x^(2k+1) &lt; x.ulp; (2k+1)*log10(x) &lt; -x.precision; 2k*log10(x)&lt; -x.precision;
                                        * 2k*(-log10(x)) &gt; x.precision; 2k*log10(1/x) &gt; x.precision
                                        */
<span class="nc" id="L1000">                                        int k = (int)(res.precision()/Math.log10(1.0/res.doubleValue()))/2 ;</span>
<span class="nc" id="L1001">                                        MathContext mcTay = new MathContext( err2prec(res.doubleValue(),xUlpDbl/k) ) ;</span>
<span class="nc" id="L1002">                                        for(int i=1 ; ; i++)</span>
                                        {
                                                /* TBD: at which precision will 2*i or 2*i+1 overflow? 
                                                */
<span class="nc" id="L1006">                                                ifac = ifac.multiply(new BigInteger(&quot;&quot;+(2*i) ) ) ;</span>
<span class="nc" id="L1007">                                                ifac = ifac.multiply( new BigInteger(&quot;&quot;+(2*i+1)) ) ;</span>
<span class="nc" id="L1008">                                                xpowi = xpowi.multiply(res).multiply(res).negate() ;</span>
<span class="nc" id="L1009">                                                BigDecimal corr = xpowi.divide(new BigDecimal(ifac),mcTay) ;</span>
<span class="nc" id="L1010">                                                resul = resul.add( corr ) ;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                                                if ( corr.abs().doubleValue() &lt; 0.5*xUlpDbl ) </span>
<span class="nc" id="L1012">                                                        break ;</span>
                                        }
                                        /* The error in the result is set by the error in x itself.
                                        */
<span class="nc" id="L1016">                                        mc = new MathContext(res.precision() ) ;</span>
<span class="nc" id="L1017">                                        return resul.round(mc) ;</span>
                                }
                        }
                }
        } /* sin */

        /** Trigonometric cosine.
        * @param x The argument in radians.
        * @return cos(x) in the range -1 to 1.
        * @since 2009-06-01
        */
        static public BigDecimal cos(final BigDecimal x)
        {
<span class="nc bnc" id="L1030" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0)</span>
<span class="nc" id="L1031">                        return cos(x.negate());</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1033">                        return BigDecimal.ONE ;</span>
                else
                {
                        /* reduce modulo 2pi
                        */
<span class="nc" id="L1038">                        BigDecimal res = mod2pi(x) ;</span>
<span class="nc" id="L1039">                        double errpi = 0.5*Math.abs(x.ulp().doubleValue()) ;</span>
<span class="nc" id="L1040">                        MathContext mc = new MathContext( 2+err2prec(3.14159,errpi) ) ;</span>
<span class="nc" id="L1041">                        BigDecimal p= pi(mc) ;</span>
<span class="nc" id="L1042">                        mc = new MathContext( x.precision() ) ;</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                        if ( res.compareTo(p) &gt; 0 )</span>
                        {
                                /* pi&lt;x&lt;=2pi: cos(x)= - cos(x-pi)
                                */
<span class="nc" id="L1047">                                return cos( subtractRound(res,p)) .negate() ;</span>
                        }
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                        else if ( res.multiply(new BigDecimal(&quot;2&quot;)).compareTo(p) &gt; 0 )</span>
                        {
                                /* pi/2&lt;x&lt;=pi: cos(x)= -cos(pi-x)
                                */
<span class="nc" id="L1053">                                return cos( subtractRound(p,res)).negate() ;</span>
                        }
                        else
                        {
                                /* for the range 0&lt;=x&lt;Pi/2 one could use cos(2x)= 1-2*sin^2(x)
                                * to split this further, or use the cos up to pi/4 and the sine higher up.
                                        throw new ProviderException(&quot;Not implemented: cosine &quot;) ;
                                */
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                                if ( res.multiply(new BigDecimal(&quot;4&quot;)).compareTo(p) &gt; 0 )</span>
                                {
                                        /* x&gt;pi/4: cos(x) = sin(pi/2-x)
                                        */
<span class="nc" id="L1065">                                        return sin( subtractRound(p.divide(new BigDecimal(&quot;2&quot;)),res) ) ;</span>
                                }
                                else
                                {
                                        /* Simple Taylor expansion, sum_{i=0..infinity} (-1)^(..)res^(2i)/(2i)! */
<span class="nc" id="L1070">                                        BigDecimal resul = BigDecimal.ONE ;</span>

                                        /* x^i */
<span class="nc" id="L1073">                                        BigDecimal xpowi = BigDecimal.ONE ;</span>

                                        /* 2i factorial */
<span class="nc" id="L1076">                                        BigInteger ifac = BigInteger.ONE ;</span>

                                        /* The absolute error in the result is the error in x^2/2 which is x times the error in x.
                                        */
<span class="nc" id="L1080">                                        double xUlpDbl = 0.5*res.ulp().doubleValue()*res.doubleValue() ;</span>

                                        /* The error in the result is set by the error in x^2/2 itself, xUlpDbl.
                                        * We need at most k terms to push x^(2k+1)/(2k+1)! below this value.
                                        * x^(2k) &lt; xUlpDbl; (2k)*log(x) &lt; log(xUlpDbl);
                                        */
<span class="nc" id="L1086">                                        int k = (int)(Math.log(xUlpDbl)/Math.log(res.doubleValue()) )/2 ;</span>
<span class="nc" id="L1087">                                        MathContext mcTay = new MathContext( err2prec(1.,xUlpDbl/k) ) ;</span>
<span class="nc" id="L1088">                                        for(int i=1 ; ; i++)</span>
                                        {
                                                /* TBD: at which precision will 2*i-1 or 2*i overflow? 
                                                */
<span class="nc" id="L1092">                                                ifac = ifac.multiply(new BigInteger(&quot;&quot;+(2*i-1) ) ) ;</span>
<span class="nc" id="L1093">                                                ifac = ifac.multiply( new BigInteger(&quot;&quot;+(2*i)) ) ;</span>
<span class="nc" id="L1094">                                                xpowi = xpowi.multiply(res).multiply(res).negate() ;</span>
<span class="nc" id="L1095">                                                BigDecimal corr = xpowi.divide(new BigDecimal(ifac),mcTay) ;</span>
<span class="nc" id="L1096">                                                resul = resul.add( corr ) ;</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                                                if ( corr.abs().doubleValue() &lt; 0.5*xUlpDbl ) </span>
<span class="nc" id="L1098">                                                        break ;</span>
                                        }
                                        /* The error in the result is governed by the error in x itself.
                                        */
<span class="nc" id="L1102">                                        mc = new MathContext( err2prec(resul.doubleValue(),xUlpDbl) ) ;</span>
<span class="nc" id="L1103">                                        return resul.round(mc) ;</span>
                                }
                        }
                }
        } /* BigDecimalMath.cos */

        /** The trigonometric tangent.
        * @param x the argument in radians.
        * @return the tan(x)
        */
        static public BigDecimal tan(final BigDecimal x)
        {
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1116">                        return BigDecimal.ZERO ;</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
                {
<span class="nc" id="L1119">                        return tan(x.negate()).negate() ;</span>
                }
                else
                {
                        /* reduce modulo pi
                        */
<span class="nc" id="L1125">                        BigDecimal res = modpi(x) ;</span>

                        /* absolute error in the result is err(x)/cos^2(x) to lowest order
                        */
<span class="nc" id="L1129">                        final double xDbl = res.doubleValue() ;</span>
<span class="nc" id="L1130">                        final double xUlpDbl = x.ulp().doubleValue()/2. ;</span>
<span class="nc" id="L1131">                        final double eps = xUlpDbl/2./Math.pow(Math.cos(xDbl),2.) ;</span>

<span class="nc bnc" id="L1133" title="All 2 branches missed.">                        if ( xDbl &gt; 0.8)</span>
                        {
                                /* tan(x) = 1/cot(x) */
<span class="nc" id="L1136">                                BigDecimal co = cot(x) ;</span>
<span class="nc" id="L1137">                                MathContext mc = new MathContext( err2prec(1./co.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1138">                                return BigDecimal.ONE.divide(co,mc) ;</span>
                        }
                        else
                        {
<span class="nc" id="L1142">                                final BigDecimal xhighpr = scalePrec(res,2) ;</span>
<span class="nc" id="L1143">                                final BigDecimal xhighprSq = multiplyRound(xhighpr,xhighpr) ;</span>

<span class="nc" id="L1145">                                BigDecimal resul = xhighpr.plus() ;</span>

                                /* x^(2i+1) */
<span class="nc" id="L1148">                                BigDecimal xpowi = xhighpr ;</span>

<span class="nc" id="L1150">                                Bernoulli b = new Bernoulli() ;</span>

                                /* 2^(2i) */
<span class="nc" id="L1153">                                BigInteger fourn = new BigInteger(&quot;4&quot;) ;</span>
                                /* (2i)! */
<span class="nc" id="L1155">                                BigInteger fac = new BigInteger(&quot;2&quot;) ;</span>

<span class="nc" id="L1157">                                for(int i= 2 ; ; i++)</span>
                                {
<span class="nc" id="L1159">                                        Rational f = b.at(2*i).abs() ;</span>
<span class="nc" id="L1160">                                        fourn = fourn.shiftLeft(2) ;</span>
<span class="nc" id="L1161">                                        fac = fac.multiply(new BigInteger(&quot;&quot;+(2*i))).multiply(new BigInteger(&quot;&quot;+(2*i-1))) ;</span>
<span class="nc" id="L1162">                                        f = f.multiply(fourn).multiply(fourn.subtract(BigInteger.ONE)).divide(fac) ;</span>
<span class="nc" id="L1163">                                        xpowi = multiplyRound(xpowi,xhighprSq) ;</span>
<span class="nc" id="L1164">                                        BigDecimal c = multiplyRound(xpowi,f) ;</span>
<span class="nc" id="L1165">                                        resul = resul.add(c) ;</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">                                        if ( Math.abs(c.doubleValue()) &lt; 0.1*eps) </span>
<span class="nc" id="L1167">                                                break;</span>
                                }
<span class="nc" id="L1169">                                MathContext mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1170">                                return resul.round(mc) ;</span>
                        }
                }
        } /* BigDecimalMath.tan */

        /** The trigonometric co-tangent.
        * @param x the argument in radians.
        * @return the cot(x)
        * @since 2009-07-31
        */
        static public BigDecimal cot(final BigDecimal x)
        {
<span class="nc bnc" id="L1182" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
                {
<span class="nc" id="L1184">                        throw new ArithmeticException(&quot;Cannot take cot of zero &quot;+ x.toString() ) ;</span>
                }
<span class="nc bnc" id="L1186" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
                {
<span class="nc" id="L1188">                        return cot(x.negate()).negate() ;</span>
                }
                else
                {
                        /* reduce modulo pi
                        */
<span class="nc" id="L1194">                        BigDecimal res = modpi(x) ;</span>

                        /* absolute error in the result is err(x)/sin^2(x) to lowest order
                        */
<span class="nc" id="L1198">                        final double xDbl = res.doubleValue() ;</span>
<span class="nc" id="L1199">                        final double xUlpDbl = x.ulp().doubleValue()/2. ;</span>
<span class="nc" id="L1200">                        final double eps = xUlpDbl/2./Math.pow(Math.sin(xDbl),2.) ;</span>

<span class="nc" id="L1202">                        final BigDecimal xhighpr = scalePrec(res,2) ;</span>
<span class="nc" id="L1203">                        final BigDecimal xhighprSq = multiplyRound(xhighpr,xhighpr) ;</span>

<span class="nc" id="L1205">                        MathContext mc = new MathContext( err2prec(xhighpr.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1206">                        BigDecimal resul = BigDecimal.ONE.divide(xhighpr,mc) ;</span>

                        /* x^(2i-1) */
<span class="nc" id="L1209">                        BigDecimal xpowi = xhighpr ;</span>

<span class="nc" id="L1211">                        Bernoulli b = new Bernoulli() ;</span>

                        /* 2^(2i) */
<span class="nc" id="L1214">                        BigInteger fourn = new BigInteger(&quot;4&quot;) ;</span>
                        /* (2i)! */
<span class="nc" id="L1216">                        BigInteger fac = BigInteger.ONE ;</span>

<span class="nc" id="L1218">                        for(int i= 1 ; ; i++)</span>
                        {
<span class="nc" id="L1220">                                Rational f = b.at(2*i) ;</span>
<span class="nc" id="L1221">                                fac = fac.multiply(new BigInteger(&quot;&quot;+(2*i))).multiply(new BigInteger(&quot;&quot;+(2*i-1))) ;</span>
<span class="nc" id="L1222">                                f = f.multiply(fourn).divide(fac) ;</span>
<span class="nc" id="L1223">                                BigDecimal c = multiplyRound(xpowi,f) ;</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                                if ( i % 2 == 0 )</span>
<span class="nc" id="L1225">                                        resul = resul.add(c) ;</span>
                                else
<span class="nc" id="L1227">                                        resul = resul.subtract(c) ;</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">                                if ( Math.abs(c.doubleValue()) &lt; 0.1*eps) </span>
<span class="nc" id="L1229">                                        break;</span>

<span class="nc" id="L1231">                                fourn = fourn.shiftLeft(2) ;</span>
<span class="nc" id="L1232">                                xpowi = multiplyRound(xpowi,xhighprSq) ;</span>
                        }
<span class="nc" id="L1234">                        mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1235">                        return resul.round(mc) ;</span>
                }
        } /* BigDecimalMath.cot */

        /** The inverse trigonometric sine.
        * @param x the argument.
        * @return the arcsin(x) in radians.
        */
        static public BigDecimal asin(final BigDecimal x)
        {
<span class="nc bnc" id="L1245" title="All 4 branches missed.">                if ( x.compareTo(BigDecimal.ONE) &gt; 0 || x.compareTo(BigDecimal.ONE.negate()) &lt; 0 )</span>
                {
<span class="nc" id="L1247">                        throw new ArithmeticException(&quot;Out of range argument &quot;+ x.toString() + &quot; of asin&quot;) ;</span>
                }
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1250">                        return BigDecimal.ZERO ;</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ONE) == 0 )</span>
                {
                        /* arcsin(1) = pi/2
                        */
<span class="nc" id="L1255">                        double errpi = Math.sqrt(x.ulp().doubleValue()) ;</span>
<span class="nc" id="L1256">                        MathContext mc = new MathContext( err2prec(3.14159,errpi) ) ;</span>
<span class="nc" id="L1257">                        return pi(mc).divide(new BigDecimal(2)) ;</span>
                }
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
                {
<span class="nc" id="L1261">                        return asin(x.negate()).negate() ;</span>
                }
<span class="nc bnc" id="L1263" title="All 2 branches missed.">                else if ( x.doubleValue() &gt; 0.7)</span>
                {
<span class="nc" id="L1265">                        final BigDecimal xCompl = BigDecimal.ONE.subtract(x) ;</span>
<span class="nc" id="L1266">                        final double xDbl = x.doubleValue() ;</span>
<span class="nc" id="L1267">                        final double xUlpDbl = x.ulp().doubleValue()/2. ;</span>
<span class="nc" id="L1268">                        final double eps = xUlpDbl/2./Math.sqrt(1.-Math.pow(xDbl,2.)) ;</span>

<span class="nc" id="L1270">                        final BigDecimal xhighpr = scalePrec(xCompl,3) ;</span>
<span class="nc" id="L1271">                        final BigDecimal xhighprV = divideRound(xhighpr,4) ;</span>

<span class="nc" id="L1273">                        BigDecimal resul = BigDecimal.ONE ;</span>

                        /* x^(2i+1) */
<span class="nc" id="L1276">                        BigDecimal xpowi = BigDecimal.ONE ;</span>

                        /* i factorial */
<span class="nc" id="L1279">                        BigInteger ifacN = BigInteger.ONE ;</span>
<span class="nc" id="L1280">                        BigInteger ifacD = BigInteger.ONE ;</span>

<span class="nc" id="L1282">                        for(int i=1 ; ; i++)</span>
                        {
<span class="nc" id="L1284">                                ifacN = ifacN.multiply(new BigInteger(&quot;&quot;+(2*i-1)) ) ;</span>
<span class="nc" id="L1285">                                ifacD = ifacD.multiply(new BigInteger(&quot;&quot;+i) ) ;</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                                if ( i == 1)</span>
<span class="nc" id="L1287">                                        xpowi = xhighprV ;</span>
                                else
<span class="nc" id="L1289">                                        xpowi = multiplyRound(xpowi,xhighprV) ;</span>
<span class="nc" id="L1290">                                BigDecimal c = divideRound( multiplyRound(xpowi,ifacN),</span>
<span class="nc" id="L1291">                                                                ifacD.multiply(new BigInteger(&quot;&quot;+(2*i+1)) ) ) ;</span>
<span class="nc" id="L1292">                                resul = resul.add(c) ;</span>
                                /* series started 1+x/12+... which yields an estimate of the sum's error
                                */
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                                if ( Math.abs(c.doubleValue()) &lt; xUlpDbl/120.) </span>
<span class="nc" id="L1296">                                        break;</span>
                        }
                        /* sqrt(2*z)*(1+...)
                        */
<span class="nc" id="L1300">                        xpowi = sqrt(xhighpr.multiply(new BigDecimal(2))) ;</span>
<span class="nc" id="L1301">                        resul = multiplyRound(xpowi,resul) ;</span>

<span class="nc" id="L1303">                        MathContext mc = new MathContext( resul.precision() ) ;</span>
<span class="nc" id="L1304">                        BigDecimal pihalf = pi(mc).divide(new BigDecimal(2)) ;</span>

<span class="nc" id="L1306">                        mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1307">                        return pihalf.subtract(resul,mc) ;</span>
                }
                else
                {
                        /* absolute error in the result is err(x)/sqrt(1-x^2) to lowest order
                        */
<span class="nc" id="L1313">                        final double xDbl = x.doubleValue() ;</span>
<span class="nc" id="L1314">                        final double xUlpDbl = x.ulp().doubleValue()/2. ;</span>
<span class="nc" id="L1315">                        final double eps = xUlpDbl/2./Math.sqrt(1.-Math.pow(xDbl,2.)) ;</span>

<span class="nc" id="L1317">                        final BigDecimal xhighpr = scalePrec(x,2) ;</span>
<span class="nc" id="L1318">                        final BigDecimal xhighprSq = multiplyRound(xhighpr,xhighpr) ;</span>

<span class="nc" id="L1320">                        BigDecimal resul = xhighpr.plus() ;</span>

                        /* x^(2i+1) */
<span class="nc" id="L1323">                        BigDecimal xpowi = xhighpr ;</span>

                        /* i factorial */
<span class="nc" id="L1326">                        BigInteger ifacN = BigInteger.ONE ;</span>
<span class="nc" id="L1327">                        BigInteger ifacD = BigInteger.ONE ;</span>

<span class="nc" id="L1329">                        for(int i=1 ; ; i++)</span>
                        {
<span class="nc" id="L1331">                                ifacN = ifacN.multiply(new BigInteger(&quot;&quot;+(2*i-1)) ) ;</span>
<span class="nc" id="L1332">                                ifacD = ifacD.multiply(new BigInteger(&quot;&quot;+(2*i)) ) ;</span>
<span class="nc" id="L1333">                                xpowi = multiplyRound(xpowi,xhighprSq) ;</span>
<span class="nc" id="L1334">                                BigDecimal c = divideRound( multiplyRound(xpowi,ifacN),</span>
<span class="nc" id="L1335">                                                                ifacD.multiply(new BigInteger(&quot;&quot;+(2*i+1)) ) ) ;</span>
<span class="nc" id="L1336">                                resul = resul.add(c) ;</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">                                if ( Math.abs(c.doubleValue()) &lt; 0.1*eps) </span>
<span class="nc" id="L1338">                                        break;</span>
                        }
<span class="nc" id="L1340">                        MathContext mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1341">                        return resul.round(mc) ;</span>
                }
        } /* BigDecimalMath.asin */

        /** The inverse trigonometric cosine.
        * @param x the argument.
        * @return the arccos(x) in radians.
        * @since 2009-09-29
        */
        static public BigDecimal acos(final BigDecimal x)
        {
                /* Essentially forwarded to pi/2 - asin(x)
                */
<span class="nc" id="L1354">                final BigDecimal xhighpr = scalePrec(x,2) ;</span>
<span class="nc" id="L1355">                BigDecimal resul = asin(xhighpr) ;</span>
<span class="nc" id="L1356">                double eps = resul.ulp().doubleValue()/2. ;</span>

<span class="nc" id="L1358">                MathContext mc = new MathContext( err2prec(3.14159,eps) ) ;</span>
<span class="nc" id="L1359">                BigDecimal pihalf = pi(mc).divide(new BigDecimal(2)) ;</span>
<span class="nc" id="L1360">                resul = pihalf.subtract(resul) ;</span>

                /* absolute error in the result is err(x)/sqrt(1-x^2) to lowest order
                */
<span class="nc" id="L1364">                final double xDbl = x.doubleValue() ;</span>
<span class="nc" id="L1365">                final double xUlpDbl = x.ulp().doubleValue()/2. ;</span>
<span class="nc" id="L1366">                eps = xUlpDbl/2./Math.sqrt(1.-Math.pow(xDbl,2.)) ;</span>

<span class="nc" id="L1368">                mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1369">                return resul.round(mc) ;</span>

        } /* BigDecimalMath.acos */

        /** The inverse trigonometric tangent.
        * @param x the argument.
        * @return the principal value of arctan(x) in radians in the range -pi/2 to +pi/2.
        * @since 2009-08-03
        */
        static public BigDecimal atan(final BigDecimal x)
        {
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
                {
<span class="nc" id="L1382">                        return atan(x.negate()).negate() ;</span>
                }
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1385">                        return BigDecimal.ZERO ;</span>
<span class="nc bnc" id="L1386" title="All 4 branches missed.">                else if ( x.doubleValue() &gt;0.7 &amp;&amp; x.doubleValue() &lt;3.0)</span>
                {
                        /* Abramowitz-Stegun 4.4.34 convergence acceleration
                        * 2*arctan(x) = arctan(2x/(1-x^2)) = arctan(y).  x=(sqrt(1+y^2)-1)/y
                        * This maps 0&lt;=y&lt;=3 to 0&lt;=x&lt;=0.73 roughly. Temporarily with 2 protectionist digits.
                        */
<span class="nc" id="L1392">                        BigDecimal y = scalePrec(x,2) ;</span>
<span class="nc" id="L1393">                        BigDecimal newx = divideRound( hypot(1,y).subtract(BigDecimal.ONE) , y);</span>

                        /* intermediate result with too optimistic error estimate*/
<span class="nc" id="L1396">                        BigDecimal resul = multiplyRound( atan(newx), 2) ;</span>

                        /* absolute error in the result is errx/(1+x^2), where errx = half  of the ulp. */
<span class="nc" id="L1399">                        double eps = x.ulp().doubleValue()/( 2.0*Math.hypot(1.0,x.doubleValue()) ) ;</span>
<span class="nc" id="L1400">                        MathContext mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1401">                        return resul.round(mc) ;</span>
                }
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                else if ( x.doubleValue() &lt; 0.71 )</span>
                {
                        /* Taylor expansion around x=0; Abramowitz-Stegun 4.4.42 */

<span class="nc" id="L1407">                        final BigDecimal xhighpr = scalePrec(x,2) ;</span>
<span class="nc" id="L1408">                        final BigDecimal xhighprSq = multiplyRound(xhighpr,xhighpr).negate() ;</span>

<span class="nc" id="L1410">                        BigDecimal resul = xhighpr.plus() ;</span>

                        /* signed x^(2i+1) */
<span class="nc" id="L1413">                        BigDecimal xpowi = xhighpr ;</span>

                        /* absolute error in the result is errx/(1+x^2), where errx = half  of the ulp.
                        */
<span class="nc" id="L1417">                        double eps = x.ulp().doubleValue()/( 2.0*Math.hypot(1.0,x.doubleValue()) ) ;</span>

<span class="nc" id="L1419">                        for(int i= 1 ; ; i++)</span>
                        {
<span class="nc" id="L1421">                                xpowi = multiplyRound(xpowi,xhighprSq) ;</span>
<span class="nc" id="L1422">                                BigDecimal c = divideRound(xpowi,2*i+1) ;</span>

<span class="nc" id="L1424">                                resul = resul.add(c) ;</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                                if ( Math.abs(c.doubleValue()) &lt; 0.1*eps) </span>
<span class="nc" id="L1426">                                        break;</span>
                        }
<span class="nc" id="L1428">                        MathContext mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1429">                        return resul.round(mc) ;</span>
                }
                else
                {
                        /* Taylor expansion around x=infinity; Abramowitz-Stegun 4.4.42 */

                        /* absolute error in the result is errx/(1+x^2), where errx = half  of the ulp.
                        */
<span class="nc" id="L1437">                        double eps = x.ulp().doubleValue()/( 2.0*Math.hypot(1.0,x.doubleValue()) ) ;</span>

                        /* start with the term pi/2; gather its precision relative to the expected result
                        */
<span class="nc" id="L1441">                        MathContext mc = new MathContext( 2+err2prec(3.1416,eps) ) ;</span>
<span class="nc" id="L1442">                        BigDecimal onepi= pi(mc) ;</span>
<span class="nc" id="L1443">                        BigDecimal resul = onepi.divide(new BigDecimal(2)) ;</span>

<span class="nc" id="L1445">                        final BigDecimal xhighpr = divideRound(-1,scalePrec(x,2)) ;</span>
<span class="nc" id="L1446">                        final BigDecimal xhighprSq = multiplyRound(xhighpr,xhighpr).negate() ;</span>

                        /* signed x^(2i+1) */
<span class="nc" id="L1449">                        BigDecimal xpowi = xhighpr ;</span>

<span class="nc" id="L1451">                        for(int i= 0 ; ; i++)</span>
                        {
<span class="nc" id="L1453">                                BigDecimal c = divideRound(xpowi,2*i+1) ;</span>

<span class="nc" id="L1455">                                resul = resul.add(c) ;</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                                if ( Math.abs(c.doubleValue()) &lt; 0.1*eps) </span>
<span class="nc" id="L1457">                                        break;</span>
<span class="nc" id="L1458">                                xpowi = multiplyRound(xpowi,xhighprSq) ;</span>
                        }
<span class="nc" id="L1460">                        mc = new MathContext( err2prec(resul.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1461">                        return resul.round(mc) ;</span>
                }
        } /* BigDecimalMath.atan */

        /** The hyperbolic cosine.
        * @param x The argument.
        * @return The cosh(x) = (exp(x)+exp(-x))/2 .
        * @author Richard J. Mathar
        * @since 2009-08-19
        */
        static public BigDecimal cosh(final BigDecimal x)
        {
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0)</span>
<span class="nc" id="L1474">                        return cos(x.negate());</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1476">                        return BigDecimal.ONE ;</span>
                else
                {
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                        if ( x.doubleValue() &gt; 1.5 )</span>
                        {
                                /* cosh^2(x) = 1+ sinh^2(x).
                                */
<span class="nc" id="L1483">                                return hypot(1, sinh(x) ) ;</span>
                        }
                        else
                        {
<span class="nc" id="L1487">                                BigDecimal xhighpr = scalePrec(x,2) ;</span>
                                /* Simple Taylor expansion, sum_{0=1..infinity} x^(2i)/(2i)! */
<span class="nc" id="L1489">                                BigDecimal resul = BigDecimal.ONE ;</span>

                                /* x^i */
<span class="nc" id="L1492">                                BigDecimal xpowi = BigDecimal.ONE ;</span>

                                /* 2i factorial */
<span class="nc" id="L1495">                                BigInteger ifac = BigInteger.ONE ;</span>

                                /* The absolute error in the result is the error in x^2/2 which is x times the error in x.
                                */
<span class="nc" id="L1499">                                double xUlpDbl = 0.5*x.ulp().doubleValue()*x.doubleValue() ;</span>

                                /* The error in the result is set by the error in x^2/2 itself, xUlpDbl.
                                * We need at most k terms to push x^(2k)/(2k)! below this value.
                                * x^(2k) &lt; xUlpDbl; (2k)*log(x) &lt; log(xUlpDbl);
                                */
<span class="nc" id="L1505">                                int k = (int)(Math.log(xUlpDbl)/Math.log(x.doubleValue()) )/2 ;</span>

                                /* The individual terms are all smaller than 1, so an estimate of 1.0 for
                                * the absolute value will give a safe relative error estimate for the indivdual terms
                                */
<span class="nc" id="L1510">                                MathContext mcTay = new MathContext( err2prec(1.,xUlpDbl/k) ) ;</span>
<span class="nc" id="L1511">                                for(int i=1 ; ; i++)</span>
                                {
                                        /* TBD: at which precision will 2*i-1 or 2*i overflow? 
                                        */
<span class="nc" id="L1515">                                        ifac = ifac.multiply(new BigInteger(&quot;&quot;+(2*i-1) ) ) ;</span>
<span class="nc" id="L1516">                                        ifac = ifac.multiply( new BigInteger(&quot;&quot;+(2*i)) ) ;</span>
<span class="nc" id="L1517">                                        xpowi = xpowi.multiply(xhighpr).multiply(xhighpr) ;</span>
<span class="nc" id="L1518">                                        BigDecimal corr = xpowi.divide(new BigDecimal(ifac),mcTay) ;</span>
<span class="nc" id="L1519">                                        resul = resul.add( corr ) ;</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                                        if ( corr.abs().doubleValue() &lt; 0.5*xUlpDbl ) </span>
<span class="nc" id="L1521">                                                break ;</span>
                                }
                                /* The error in the result is governed by the error in x itself.
                                */
<span class="nc" id="L1525">                                MathContext mc = new MathContext( err2prec(resul.doubleValue(),xUlpDbl) ) ;</span>
<span class="nc" id="L1526">                                return resul.round(mc) ;</span>
                        }
                }
        } /* BigDecimalMath.cosh */

        /** The hyperbolic sine.
        * @param x the argument.
        * @return the sinh(x) = (exp(x)-exp(-x))/2 .
        * @author Richard J. Mathar
        * @since 2009-08-19
        */
        static public BigDecimal sinh(final BigDecimal x)
        {
<span class="nc bnc" id="L1539" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0)</span>
<span class="nc" id="L1540">                        return sinh(x.negate()).negate() ;</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1542">                        return BigDecimal.ZERO ;</span>
                else
                {
<span class="nc bnc" id="L1545" title="All 2 branches missed.">                        if ( x.doubleValue() &gt; 2.4 )</span>
                        {
                                /* Move closer to zero with sinh(2x)= 2*sinh(x)*cosh(x).
                                */
<span class="nc" id="L1549">                                BigDecimal two = new BigDecimal(2) ;</span>
<span class="nc" id="L1550">                                BigDecimal xhalf = x.divide(two) ;</span>
<span class="nc" id="L1551">                                BigDecimal resul =  sinh(xhalf).multiply(cosh(xhalf)).multiply(two) ;</span>
                                /* The error in the result is set by the error in x itself.
                                * The first derivative of sinh(x) is cosh(x), so the absolute error
                                * in the result is cosh(x)*errx, and the relative error is coth(x)*errx = errx/tanh(x)
                                */ 
<span class="nc" id="L1556">                                double eps =  Math.tanh(x.doubleValue()) ;</span>
<span class="nc" id="L1557">                                MathContext mc = new MathContext( err2prec(0.5*x.ulp().doubleValue()/eps) ) ;</span>
<span class="nc" id="L1558">                                return resul.round(mc) ;</span>
                        }
                        else
                        {
<span class="nc" id="L1562">                                BigDecimal xhighpr = scalePrec(x,2) ;</span>
                                /* Simple Taylor expansion, sum_{i=0..infinity} x^(2i+1)/(2i+1)! */
<span class="nc" id="L1564">                                BigDecimal resul = xhighpr ;</span>

                                /* x^i */
<span class="nc" id="L1567">                                BigDecimal xpowi = xhighpr ;</span>

                                /* 2i+1 factorial */
<span class="nc" id="L1570">                                BigInteger ifac = BigInteger.ONE ;</span>

                                /* The error in the result is set by the error in x itself.
                                */
<span class="nc" id="L1574">                                double xUlpDbl = x.ulp().doubleValue() ;</span>

                                /* The error in the result is set by the error in x itself.
                                * We need at most k terms to squeeze x^(2k+1)/(2k+1)! below this value.
                                * x^(2k+1) &lt; x.ulp; (2k+1)*log10(x) &lt; -x.precision; 2k*log10(x)&lt; -x.precision;
                                * 2k*(-log10(x)) &gt; x.precision; 2k*log10(1/x) &gt; x.precision
                                */
<span class="nc" id="L1581">                                int k = (int)(x.precision()/Math.log10(1.0/xhighpr.doubleValue()))/2 ;</span>
<span class="nc" id="L1582">                                MathContext mcTay = new MathContext( err2prec(x.doubleValue(),xUlpDbl/k) ) ;</span>
<span class="nc" id="L1583">                                for(int i=1 ; ; i++)</span>
                                {
                                        /* TBD: at which precision will 2*i or 2*i+1 overflow? 
                                        */
<span class="nc" id="L1587">                                        ifac = ifac.multiply(new BigInteger(&quot;&quot;+(2*i) ) ) ;</span>
<span class="nc" id="L1588">                                        ifac = ifac.multiply( new BigInteger(&quot;&quot;+(2*i+1)) ) ;</span>
<span class="nc" id="L1589">                                        xpowi = xpowi.multiply(xhighpr).multiply(xhighpr) ;</span>
<span class="nc" id="L1590">                                        BigDecimal corr = xpowi.divide(new BigDecimal(ifac),mcTay) ;</span>
<span class="nc" id="L1591">                                        resul = resul.add( corr ) ;</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">                                        if ( corr.abs().doubleValue() &lt; 0.5*xUlpDbl ) </span>
<span class="nc" id="L1593">                                                break ;</span>
                                }
                                /* The error in the result is set by the error in x itself.
                                */
<span class="nc" id="L1597">                                MathContext mc = new MathContext(x.precision() ) ;</span>
<span class="nc" id="L1598">                                return resul.round(mc) ;</span>
                        }
                }
        } /* BigDecimalMath.sinh */

        /** The hyperbolic tangent.
        * @param x The argument.
        * @return The tanh(x) = sinh(x)/cosh(x).
        * @author Richard J. Mathar
        * @since 2009-08-20
        */
        static public BigDecimal tanh(final BigDecimal x)
        {
<span class="nc bnc" id="L1611" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0)</span>
<span class="nc" id="L1612">                        return tanh(x.negate()).negate() ;</span>
<span class="nc bnc" id="L1613" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1614">                        return BigDecimal.ZERO ;</span>
                else
                {
<span class="nc" id="L1617">                        BigDecimal xhighpr = scalePrec(x,2) ;</span>

                        /* tanh(x) = (1-e^(-2x))/(1+e^(-2x)) .
                        */
<span class="nc" id="L1621">                        BigDecimal exp2x = exp( xhighpr.multiply(new BigDecimal(-2)) ) ;</span>

                        /* The error in tanh x is err(x)/cosh^2(x).
                        */
<span class="nc" id="L1625">                        double eps = 0.5*x.ulp().doubleValue()/Math.pow( Math.cosh(x.doubleValue()), 2.0 ) ;</span>
<span class="nc" id="L1626">                        MathContext mc = new MathContext( err2prec(Math.tanh(x.doubleValue()),eps) ) ;</span>
<span class="nc" id="L1627">                        return BigDecimal.ONE.subtract(exp2x).divide( BigDecimal.ONE.add(exp2x), mc) ;</span>
                }
        } /* BigDecimalMath.tanh */

        /** The inverse hyperbolic sine.
        * @param x The argument.
        * @return The arcsinh(x) .
        * @author Richard J. Mathar
        * @since 2009-08-20
        */
        static public BigDecimal asinh(final BigDecimal x)
        {
<span class="nc bnc" id="L1639" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L1640">                        return BigDecimal.ZERO ;</span>
                else
                {
<span class="nc" id="L1643">                        BigDecimal xhighpr = scalePrec(x,2) ;</span>

                        /* arcsinh(x) = log(x+hypot(1,x)) 
                        */
<span class="nc" id="L1647">                        BigDecimal logx = log(hypot(1,xhighpr).add(xhighpr)) ;</span>

                        /* The absolute error in arcsinh x is err(x)/sqrt(1+x^2)
                        */
<span class="nc" id="L1651">                        double xDbl = x.doubleValue() ;</span>
<span class="nc" id="L1652">                        double eps = 0.5*x.ulp().doubleValue()/Math.hypot(1.,xDbl ) ;</span>
<span class="nc" id="L1653">                        MathContext mc = new MathContext( err2prec(logx.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1654">                        return logx.round(mc) ;</span>
                }
        } /* BigDecimalMath.asinh */

        /** The inverse hyperbolic cosine.
        * @param x The argument.
        * @return The arccosh(x) .
        * @author Richard J. Mathar
        * @since 2009-08-20
        */
        static public BigDecimal acosh(final BigDecimal x)
        {
<span class="nc bnc" id="L1666" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ONE) &lt; 0 )</span>
<span class="nc" id="L1667">                        throw new ArithmeticException(&quot;Out of range argument cosh &quot;+x.toString() ) ;</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">                else if ( x.compareTo(BigDecimal.ONE) == 0 )</span>
<span class="nc" id="L1669">                        return BigDecimal.ZERO ;</span>
                else
                {
<span class="nc" id="L1672">                        BigDecimal xhighpr = scalePrec(x,2) ;</span>

                        /* arccosh(x) = log(x+sqrt(x^2-1)) 
                        */
<span class="nc" id="L1676">                        BigDecimal logx = log( sqrt(xhighpr.pow(2).subtract(BigDecimal.ONE) ) .add(xhighpr)) ;</span>

                        /* The absolute error in arcsinh x is err(x)/sqrt(x^2-1)
                        */
<span class="nc" id="L1680">                        double xDbl = x.doubleValue() ;</span>
<span class="nc" id="L1681">                        double eps = 0.5*x.ulp().doubleValue()/Math.sqrt(xDbl*xDbl-1.) ;</span>
<span class="nc" id="L1682">                        MathContext mc = new MathContext( err2prec(logx.doubleValue(),eps) ) ;</span>
<span class="nc" id="L1683">                        return logx.round(mc) ;</span>
                }
        } /* BigDecimalMath.acosh */

        /** The Gamma function.
        * @param x The argument.
        * @return Gamma(x).
        * @since 2009-08-06
        */
        static public BigDecimal Gamma(final BigDecimal x)
        {
                /* reduce to interval near 1.0 with the functional relation, Abramowitz-Stegun 6.1.33
                */
<span class="nc bnc" id="L1696" title="All 2 branches missed.">                if ( x.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L1697">                        return divideRound(Gamma( x.add(BigDecimal.ONE) ),x) ;</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">                else if ( x.doubleValue() &gt; 1.5 )</span>
                {
                        /* Gamma(x) = Gamma(xmin+n) = Gamma(xmin)*Pochhammer(xmin,n).
                        */
<span class="nc" id="L1702">                        int n = (int) ( x.doubleValue()-0.5 );</span>
<span class="nc" id="L1703">                        BigDecimal xmin1 = x.subtract(new BigDecimal(n)) ;</span>
<span class="nc" id="L1704">                        return multiplyRound(Gamma(xmin1), pochhammer(xmin1,n) ) ;</span>
                }
                else
                {
                        /* apply Abramowitz-Stegun 6.1.33
                        */
<span class="nc" id="L1710">                        BigDecimal z = x.subtract(BigDecimal.ONE) ;</span>

                        /* add intermediately 2 digits to the partial sum accumulation
                        */
<span class="nc" id="L1714">                        z = scalePrec(z,2) ;</span>
<span class="nc" id="L1715">                        MathContext mcloc = new MathContext(z.precision()) ;</span>

                        /* measure of the absolute error is the relative error in the first, logarithmic term
                        */
<span class="nc" id="L1719">                        double eps = x.ulp().doubleValue()/x.doubleValue() ;</span>

<span class="nc" id="L1721">                        BigDecimal resul = log( scalePrec(x,2)).negate() ;</span>

<span class="nc bnc" id="L1723" title="All 2 branches missed.">                        if ( x.compareTo(BigDecimal.ONE) != 0 )</span>
                        {

<span class="nc" id="L1726">                                BigDecimal gammCompl = BigDecimal.ONE.subtract(gamma(mcloc) ) ;</span>
<span class="nc" id="L1727">                                resul = resul.add( multiplyRound(z,gammCompl) ) ;</span>
<span class="nc" id="L1728">                                for(int n=2; ;n++)</span>
                                {
                                        /* multiplying z^n/n by zeta(n-1) means that the two relative errors add.
                                        * so the requirement in the relative error of zeta(n)-1 is that this is somewhat
                                        * smaller than the relative error in z^n/n (the absolute error of thelatter  is the
                                        * absolute error in z) 
                                        */
<span class="nc" id="L1735">                                        BigDecimal c = divideRound(z.pow(n,mcloc),n) ;</span>
<span class="nc" id="L1736">                                        MathContext m = new MathContext( err2prec(n*z.ulp().doubleValue()/2./z.doubleValue()) ) ;</span>
<span class="nc" id="L1737">                                        c = c.round(m) ;</span>

                                        /* At larger n, zeta(n)-1 is roughly 1/2^n. The product is c/2^n.
                                        * The relative error in c is c.ulp/2/c . The error in the product should be small versus eps/10.
                                        * Error from 1/2^n is c*err(sigma-1).
                                        * We need a relative error of zeta-1 of the order of c.ulp/50/c. This is an absolute
                                        * error in zeta-1 of c.ulp/50/c/2^n, and also the absolute error in zeta, because zeta is
                                        * of the order of 1.
                                        */
<span class="nc bnc" id="L1746" title="All 2 branches missed.">                                        if ( eps/100./c.doubleValue() &lt; 0.01 )</span>
<span class="nc" id="L1747">                                                m = new MathContext( err2prec(eps/100./c.doubleValue()) ) ;</span>
                                        else
<span class="nc" id="L1749">                                                m = new MathContext( 2) ;</span>
                                        /* zeta(n) -1 */
<span class="nc" id="L1751">                                        BigDecimal zetm1 = zeta(n,m).subtract(BigDecimal.ONE) ;</span>
<span class="nc" id="L1752">                                        c = multiplyRound(c,zetm1) ;</span>

<span class="nc bnc" id="L1754" title="All 2 branches missed.">                                        if ( n % 2 == 0 )</span>
<span class="nc" id="L1755">                                                resul = resul.add(c) ;</span>
                                        else
<span class="nc" id="L1757">                                                resul = resul.subtract(c) ;</span>
        
                                        /* alternating sum, so truncating as eps is reached suffices 
                                        */
<span class="nc bnc" id="L1761" title="All 2 branches missed.">                                        if ( Math.abs(c.doubleValue()) &lt; eps)</span>
<span class="nc" id="L1762">                                                break;</span>
                                }
                        }
                        
                        /* The relative error in the result is the absolute error in the
                        * input variable times the digamma (psi) value at that point.
                        */
<span class="nc" id="L1769">                        double zdbl = z.doubleValue() ;</span>
<span class="nc" id="L1770">                        eps = psi(zdbl)* x.ulp().doubleValue()/2. ;</span>
<span class="nc" id="L1771">                        mcloc = new MathContext( err2prec(eps) ) ;</span>
<span class="nc" id="L1772">                        return exp(resul).round(mcloc) ;</span>
                }
        } /* BigDecimalMath.gamma */

        /** The Gamma function.
        * @param q The argument.
        * @param mc The required accuracy in the result.
        * @return Gamma(x).
        * @since 2010-05-26
        */
        static public BigDecimal Gamma(final Rational q, final MathContext mc)
        {
<span class="nc bnc" id="L1784" title="All 2 branches missed.">                if ( q.isBigInteger() )</span>
                {
<span class="nc bnc" id="L1786" title="All 2 branches missed.">                        if ( q.compareTo(Rational.ZERO) &lt;= 0 )</span>
<span class="nc" id="L1787">                                throw new ArithmeticException(&quot;Gamma at &quot;+q.toString() ) ;</span>
                        else
                        {
                                /* Gamma(n) = (n-1)! */
<span class="nc" id="L1791">                                Factorial f = new Factorial() ;</span>
<span class="nc" id="L1792">                                BigInteger g = f.at( q.trunc().intValue()-1 ) ;</span>
<span class="nc" id="L1793">                                return scalePrec(new BigDecimal(g),mc) ;</span>
                        }
                }
<span class="nc bnc" id="L1796" title="All 2 branches missed.">                else if ( q.b.intValue() == 2 )</span>
                {
                        /* half integer cases which are related to sqrt(pi)
                        */
<span class="nc" id="L1800">                        BigDecimal p = sqrt(pi(mc)) ;</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">                        if ( q.compareTo(Rational.ZERO) &gt;= 0 )</span>
                        {
<span class="nc" id="L1803">                                Rational pro = Rational.ONE ;</span>
<span class="nc" id="L1804">                                Rational f = q.subtract(1) ;</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">                                while ( f.compareTo(Rational.ZERO) &gt; 0 )</span>
                                {
<span class="nc" id="L1807">                                        pro = pro.multiply(f) ;</span>
<span class="nc" id="L1808">                                        f = f.subtract(1) ;</span>
                                }
<span class="nc" id="L1810">                                return multiplyRound(p,pro) ;</span>
                        }
                        else
                        {
<span class="nc" id="L1814">                                Rational pro = Rational.ONE ;</span>
<span class="nc" id="L1815">                                Rational f = q ;</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">                                while ( f.compareTo(Rational.ZERO) &lt; 0 )</span>
                                {
<span class="nc" id="L1818">                                        pro = pro.divide(f) ;</span>
<span class="nc" id="L1819">                                        f = f.add(1) ;</span>
                                }
<span class="nc" id="L1821">                                return multiplyRound(p,pro) ;</span>
                        }
                }
                else
                {
                        /* The relative error of the result is psi(x)*Delta(x). Tune Delta(x) such
                        * that this is equivalent to mc: Delta(x) = precision/psi(x).
                        */
<span class="nc" id="L1829">                        double qdbl = q.doubleValue() ;</span>
<span class="nc" id="L1830">                        double deltx = 5.*Math.pow(10.,-mc.getPrecision()) /psi(qdbl) ;</span>

<span class="nc" id="L1832">                        MathContext mcx  = new MathContext( err2prec(qdbl,deltx) ) ;</span>
<span class="nc" id="L1833">                        BigDecimal x =  q.BigDecimalValue(mcx) ;</span>

                        /* forward calculation to the general floating point case */
<span class="nc" id="L1836">                        return Gamma(x) ;</span>
                }
        } /* BigDecimalMath.Gamma */

        /** Pochhammer's  function.
        * @param x The main argument.
        * @param n The non-negative index.
        * @return (x)_n = x(x+1)(x+2)*...*(x+n-1).
        * @since 2009-08-19
        */
        static public BigDecimal pochhammer(final BigDecimal x, final int n)
        {
                /* reduce to interval near 1.0 with the functional relation, Abramowitz-Stegun 6.1.33
                */
<span class="nc bnc" id="L1850" title="All 2 branches missed.">                if ( n &lt; 0 )</span>
<span class="nc" id="L1851">                        throw new ProviderException(&quot;Not implemented: pochhammer with negative index &quot;+n) ;</span>
<span class="nc bnc" id="L1852" title="All 2 branches missed.">                else if ( n == 0 )</span>
<span class="nc" id="L1853">                        return BigDecimal.ONE ;</span>
                else
                {
                        /* internally two safety digits
                        */
<span class="nc" id="L1858">                        BigDecimal xhighpr = scalePrec(x,2) ;</span>
<span class="nc" id="L1859">                        BigDecimal resul = xhighpr ;</span>

<span class="nc" id="L1861">                        double xUlpDbl = x.ulp().doubleValue() ;</span>
<span class="nc" id="L1862">                        double xDbl = x.doubleValue() ;</span>
                        /* relative error of the result is the sum of the relative errors of the factors
                        */
<span class="nc" id="L1865">                        double eps = 0.5*xUlpDbl/Math.abs(xDbl) ;</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">                        for (int i =1 ; i &lt; n ; i++)</span>
                        {
<span class="nc" id="L1868">                                eps += 0.5*xUlpDbl/Math.abs(xDbl+i) ;</span>
<span class="nc" id="L1869">                                resul = resul.multiply( xhighpr.add(new BigDecimal(i)) ) ;</span>
<span class="nc" id="L1870">                                final MathContext mcloc = new MathContext(4+ err2prec(eps) ) ;</span>
<span class="nc" id="L1871">                                resul = resul.round(mcloc) ;</span>
                        }
<span class="nc" id="L1873">                        return resul.round(new MathContext(err2prec(eps)) )  ;</span>
                }
        } /* BigDecimalMath.pochhammer */

        /** Reduce value to the interval [0,2*Pi].
        * @param x the original value
        * @return the value modulo 2*pi in the interval from 0 to 2*pi.
        * @since 2009-06-01
        */
        static public BigDecimal mod2pi(BigDecimal x)
        {
                /* write x= 2*pi*k+r with the precision in r defined by the precision of x and not
                * compromised by the precision of 2*pi, so the ulp of 2*pi*k should match the ulp of x.
                * First get a guess of k to figure out how many digits of 2*pi are needed.
                */
<span class="nc" id="L1888">                int k = (int)(0.5*x.doubleValue()/Math.PI) ;</span>

                /* want to have err(2*pi*k)&lt; err(x)=0.5*x.ulp, so err(pi) = err(x)/(4k) with two safety digits
                */
                double err2pi ;
<span class="nc bnc" id="L1893" title="All 2 branches missed.">                if ( k != 0 )</span>
<span class="nc" id="L1894">                        err2pi = 0.25*Math.abs(x.ulp().doubleValue()/k) ;</span>
                else
<span class="nc" id="L1896">                        err2pi = 0.5*Math.abs(x.ulp().doubleValue()) ;</span>
<span class="nc" id="L1897">                MathContext mc = new MathContext( 2+err2prec(6.283,err2pi) ) ;</span>
<span class="nc" id="L1898">                BigDecimal twopi= pi(mc).multiply(new BigDecimal(2)) ;</span>

                /* Delegate the actual operation to the BigDecimal class, which may return
                * a negative value of x was negative .
                */
<span class="nc" id="L1903">                BigDecimal res = x.remainder(twopi) ;</span>
<span class="nc bnc" id="L1904" title="All 2 branches missed.">                if ( res.compareTo(BigDecimal.ZERO) &lt; 0 )</span>
<span class="nc" id="L1905">                        res =  res.add(twopi) ;</span>

                /* The actual precision is set by the input value, its absolute value of x.ulp()/2.
                */
<span class="nc" id="L1909">                mc = new MathContext( err2prec(res.doubleValue(),x.ulp().doubleValue()/2.) ) ;</span>
<span class="nc" id="L1910">                return res.round(mc) ;</span>
        } /* mod2pi */

        /** Reduce value to the interval [-Pi/2,Pi/2].
        * @param x The original value
        * @return The value modulo pi, shifted to the interval from -Pi/2 to Pi/2.
        * @since 2009-07-31
        */
        static public BigDecimal modpi(BigDecimal x)
        {
                /* write x= pi*k+r with the precision in r defined by the precision of x and not
                * compromised by the precision of pi, so the ulp of pi*k should match the ulp of x.
                * First get a guess of k to figure out how many digits of pi are needed.
                */
<span class="nc" id="L1924">                int k = (int)(x.doubleValue()/Math.PI) ;</span>

                /* want to have err(pi*k)&lt; err(x)=x.ulp/2, so err(pi) = err(x)/(2k) with two safety digits
                */
                double errpi ;
<span class="nc bnc" id="L1929" title="All 2 branches missed.">                if ( k != 0 )</span>
<span class="nc" id="L1930">                        errpi = 0.5*Math.abs(x.ulp().doubleValue()/k) ;</span>
                else
<span class="nc" id="L1932">                        errpi = 0.5*Math.abs(x.ulp().doubleValue()) ;</span>
<span class="nc" id="L1933">                MathContext mc = new MathContext( 2+err2prec(3.1416,errpi) ) ;</span>
<span class="nc" id="L1934">                BigDecimal onepi= pi(mc) ;</span>
<span class="nc" id="L1935">                BigDecimal pihalf = onepi.divide(new BigDecimal(2)) ;</span>

                /* Delegate the actual operation to the BigDecimal class, which may return
                * a negative value of x was negative .
                */
<span class="nc" id="L1940">                BigDecimal res = x.remainder(onepi) ;</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">                if ( res.compareTo(pihalf) &gt; 0 )</span>
<span class="nc" id="L1942">                        res =  res.subtract(onepi) ;</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">                else if ( res.compareTo(pihalf.negate()) &lt; 0 )</span>
<span class="nc" id="L1944">                        res =  res.add(onepi) ;</span>

                /* The actual precision is set by the input value, its absolute value of x.ulp()/2.
                */
<span class="nc" id="L1948">                mc = new MathContext( err2prec(res.doubleValue(),x.ulp().doubleValue()/2.) ) ;</span>
<span class="nc" id="L1949">                return res.round(mc) ;</span>
        } /* modpi */

        /** Riemann zeta function.
        * @param n The positive integer argument.
        * @param mc Specification of the accuracy of the result.
        * @return zeta(n).
        * @since 2009-08-05
        */
        static public BigDecimal zeta(final int n, final MathContext mc)
        {
<span class="nc bnc" id="L1960" title="All 2 branches missed.">                if( n &lt;= 0 )</span>
<span class="nc" id="L1961">                        throw new ProviderException(&quot;Not implemented: zeta at negative argument &quot;+n) ;</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                if( n == 1 )</span>
<span class="nc" id="L1963">                        throw new ArithmeticException(&quot;Pole at zeta(1) &quot;) ;</span>

<span class="nc bnc" id="L1965" title="All 2 branches missed.">                if( n % 2 == 0 )</span>
                {
                        /* Even indices. Abramowitz-Stegun 23.2.16. Start with 2^(n-1)*B(n)/n!
                        */
<span class="nc" id="L1969">                        Rational b = (new Bernoulli()).at(n).abs() ;</span>
<span class="nc" id="L1970">                        b = b.divide((new Factorial()).at(n)) ;</span>
<span class="nc" id="L1971">                        b = b.multiply( BigInteger.ONE.shiftLeft(n-1) );</span>

                        /* to be multiplied by pi^n. Absolute error in the result of pi^n is n times
                        * error in pi times pi^(n-1). Relative error is n*error(pi)/pi, requested by mc.
                        * Need one more digit in pi if n=10, two digits if n=100 etc, and add one extra digit.
                        */
<span class="nc" id="L1977">                        MathContext mcpi = new MathContext( mc.getPrecision() + (int)(Math.log10(10.0*n)) ) ;</span>
<span class="nc" id="L1978">                        final BigDecimal piton = pi(mcpi).pow(n,mc) ;</span>
<span class="nc" id="L1979">                        return multiplyRound( piton, b) ;</span>
                }
<span class="nc bnc" id="L1981" title="All 2 branches missed.">                else if ( n == 3)</span>
                {
                        /* Broadhurst BBP &lt;a href=&quot;http://arxiv.org/abs/math/9803067&quot;&gt;arXiv:math/9803067&lt;/a&gt;
                        * Error propagation: S31 is roughly 0.087, S33 roughly 0.131
                        */
<span class="nc" id="L1986">                        int[] a31 = {1,-7,-1,10,-1,-7,1,0} ; </span>
<span class="nc" id="L1987">                        int[] a33 = {1,1,-1,-2,-1,1,1,0} ; </span>
<span class="nc" id="L1988">                        BigDecimal S31 = broadhurstBBP(3,1,a31,mc) ;</span>
<span class="nc" id="L1989">                        BigDecimal S33 = broadhurstBBP(3,3,a33,mc) ;</span>
<span class="nc" id="L1990">                        S31 = S31.multiply(new BigDecimal(48)) ;</span>
<span class="nc" id="L1991">                        S33 = S33.multiply(new BigDecimal(32)) ;</span>
<span class="nc" id="L1992">                        return S31.add(S33).divide(new BigDecimal(7),mc) ;</span>
                }
<span class="nc bnc" id="L1994" title="All 2 branches missed.">                else if ( n == 5)</span>
                {
                        /* Broadhurst BBP &lt;a href=http://arxiv.org/abs/math/9803067&quot;&gt;arXiv:math/9803067&lt;/a&gt;
                        * Error propagation: S51 is roughly -11.15, S53 roughly 22.165, S55 is roughly 0.031
                        * 9*2048*S51/6265 = -3.28. 7*2038*S53/61651= 5.07. 738*2048*S55/61651= 0.747.
                        * The result is of the order 1.03, so we add 2 digits to S51 and S52 and one digit to S55.
                        */
<span class="nc" id="L2001">                        int[] a51 = {31,-1614,-31,-6212,-31,-1614,31,74552} ; </span>
<span class="nc" id="L2002">                        int[] a53 = {173,284,-173,-457,-173,284,173,-111} ; </span>
<span class="nc" id="L2003">                        int[] a55 = {1,0,-1,-1,-1,0,1,1} ; </span>
<span class="nc" id="L2004">                        BigDecimal S51 = broadhurstBBP(5,1,a51, new MathContext(2+mc.getPrecision()) ) ;</span>
<span class="nc" id="L2005">                        BigDecimal S53 = broadhurstBBP(5,3,a53, new MathContext(2+mc.getPrecision()) ) ;</span>
<span class="nc" id="L2006">                        BigDecimal S55 = broadhurstBBP(5,5,a55, new MathContext(1+mc.getPrecision()) ) ;</span>
<span class="nc" id="L2007">                        S51 = S51.multiply(new BigDecimal(18432)) ;</span>
<span class="nc" id="L2008">                        S53 = S53.multiply(new BigDecimal(14336)) ;</span>
<span class="nc" id="L2009">                        S55 = S55.multiply(new BigDecimal(1511424)) ;</span>
<span class="nc" id="L2010">                        return S51.add(S53).subtract(S55).divide(new BigDecimal(62651),mc) ;</span>
                }
                else
                {
                        /* Cohen et al Exp Math 1 (1) (1992) 25
                        */
<span class="nc" id="L2016">                        Rational betsum = new Rational() ;</span>
<span class="nc" id="L2017">                        Bernoulli bern = new Bernoulli() ;</span>
<span class="nc" id="L2018">                        Factorial fact = new Factorial() ;</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">                        for(int npr=0 ; npr &lt;= (n+1)/2 ; npr++)</span>
                        {
<span class="nc" id="L2021">                                Rational b = bern.at(2*npr).multiply(bern.at(n+1-2*npr)) ;</span>
<span class="nc" id="L2022">                                b = b.divide(fact.at(2*npr)).divide(fact.at(n+1-2*npr)) ;</span>
<span class="nc" id="L2023">                                b = b.multiply(1-2*npr) ;</span>
<span class="nc bnc" id="L2024" title="All 2 branches missed.">                                if ( npr % 2 ==0 )</span>
<span class="nc" id="L2025">                                        betsum = betsum.add(b) ;</span>
                                else
<span class="nc" id="L2027">                                        betsum = betsum.subtract(b) ;</span>
                        }
<span class="nc" id="L2029">                        betsum = betsum.divide(n-1) ;</span>
                        /* The first term, including the facor (2pi)^n, is essentially most
                        * of the result, near one. The second term below is roughly in the range 0.003 to 0.009.
                        * So the precision here is matching the precisionn requested by mc, and the precision
                        * requested for 2*pi is in absolute terms adjusted.
                        */
<span class="nc" id="L2035">                        MathContext mcloc = new MathContext( 2+mc.getPrecision() + (int)(Math.log10((double)(n))) ) ;</span>
<span class="nc" id="L2036">                        BigDecimal ftrm = pi(mcloc).multiply(new BigDecimal(2)) ;</span>
<span class="nc" id="L2037">                        ftrm = ftrm.pow(n) ;</span>
<span class="nc" id="L2038">                        ftrm = multiplyRound(ftrm, betsum.BigDecimalValue(mcloc) ) ;</span>
<span class="nc" id="L2039">                        BigDecimal exps = new BigDecimal(0) ;</span>

                        /* the basic accuracy of the accumulated terms before multiplication with 2
                        */
<span class="nc" id="L2043">                        double eps = Math.pow(10.,-mc.getPrecision()) ;</span>

<span class="nc bnc" id="L2045" title="All 2 branches missed.">                        if ( n % 4 == 3)</span>
                        {
                                /* since the argument n is at least 7 here, the drop
                                * of the terms is at rather constant pace at least 10^-3, for example
                                * 0.0018, 0.2e-7, 0.29e-11, 0.74e-15 etc for npr=1,2,3.... We want 2 times these terms
                                * fall below eps/10.
                                */
<span class="nc" id="L2052">                                int kmax = mc.getPrecision()/3 ;</span>
<span class="nc" id="L2053">                                eps /= kmax ;</span>
                                /* need an error of eps for 2/(exp(2pi)-1) = 0.0037
                                * The absolute error is 4*exp(2pi)*err(pi)/(exp(2pi)-1)^2=0.0075*err(pi)
                                */
<span class="nc" id="L2057">                                BigDecimal exp2p = pi( new MathContext(3+err2prec(3.14, eps/0.0075)) ) ;</span>
<span class="nc" id="L2058">                                exp2p = exp(exp2p.multiply(new BigDecimal(2))) ;</span>
<span class="nc" id="L2059">                                BigDecimal c =  exp2p.subtract(BigDecimal.ONE) ;</span>
<span class="nc" id="L2060">                                exps = divideRound(1,c) ;</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">                                for(int npr=2 ; npr&lt;= kmax ; npr++)</span>
                                {
                                        /* the error estimate above for npr=1 is the worst case of
                                        * the absolute error created by an error in 2pi. So we can
                                        * safely re-use the exp2p value computed above without
                                        * reassessment of its error.
                                        */
<span class="nc" id="L2068">                                        c =  powRound(exp2p,npr).subtract(BigDecimal.ONE) ;</span>
<span class="nc" id="L2069">                                        c =  multiplyRound(c, (new BigInteger(&quot;&quot;+npr)).pow(n) ) ;</span>
<span class="nc" id="L2070">                                        c =  divideRound(1,c) ;</span>
<span class="nc" id="L2071">                                        exps = exps.add(c) ;</span>
                                }
<span class="nc" id="L2073">                        }</span>
                        else
                        {
                                /* since the argument n is at least 9 here, the drop
                                * of the terms is at rather constant pace at least 10^-3, for example
                                * 0.0096, 0.5e-7, 0.3e-11, 0.6e-15 etc. We want these terms
                                * fall below eps/10.
                                */
<span class="nc" id="L2081">                                int kmax = (1+mc.getPrecision())/3 ;</span>
<span class="nc" id="L2082">                                eps /= kmax ;</span>
                                /* need an error of eps for 2/(exp(2pi)-1)*(1+4*Pi/8/(1-exp(-2pi)) = 0.0096
                                * at k=7 or = 0.00766 at k=13 for example.
                                * The absolute error is 0.017*err(pi) at k=9, 0.013*err(pi) at k=13, 0.012 at k=17
                                */
<span class="nc" id="L2087">                                BigDecimal twop = pi( new MathContext(3+err2prec(3.14, eps/0.017)) ) ;</span>
<span class="nc" id="L2088">                                twop = twop.multiply(new BigDecimal(2)) ;</span>
<span class="nc" id="L2089">                                BigDecimal exp2p = exp(twop) ;</span>
<span class="nc" id="L2090">                                BigDecimal c =  exp2p.subtract(BigDecimal.ONE) ;</span>
<span class="nc" id="L2091">                                exps = divideRound(1,c) ;</span>
<span class="nc" id="L2092">                                c =  BigDecimal.ONE.subtract(divideRound(1,exp2p)) ;</span>
<span class="nc" id="L2093">                                c =  divideRound(twop,c).multiply(new BigDecimal(2)) ;</span>
<span class="nc" id="L2094">                                c =  divideRound(c,n-1).add(BigDecimal.ONE) ;</span>
<span class="nc" id="L2095">                                exps = multiplyRound(exps,c) ;</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">                                for(int npr=2 ; npr&lt;= kmax ; npr++)</span>
                                {
<span class="nc" id="L2098">                                        c =  powRound(exp2p,npr).subtract(BigDecimal.ONE) ;</span>
<span class="nc" id="L2099">                                        c =  multiplyRound(c, (new BigInteger(&quot;&quot;+npr)).pow(n) ) ;</span>

<span class="nc" id="L2101">                                        BigDecimal d =  divideRound(1, exp2p.pow(npr) ) ;</span>
<span class="nc" id="L2102">                                        d =  BigDecimal.ONE.subtract(d) ;</span>
<span class="nc" id="L2103">                                        d =  divideRound(twop,d).multiply(new BigDecimal(2*npr)) ;</span>
<span class="nc" id="L2104">                                        d =  divideRound(d,n-1).add(BigDecimal.ONE) ;</span>

<span class="nc" id="L2106">                                        d = divideRound(d,c) ;</span>

<span class="nc" id="L2108">                                        exps = exps.add(d) ;</span>
                                }
                        }
<span class="nc" id="L2111">                        exps = exps.multiply(new BigDecimal(2)) ;</span>
<span class="nc" id="L2112">                        return ftrm.subtract(exps,mc) ;</span>
                }
        } /* zeta */

        /** Riemann zeta function.
        * @param n The positive integer argument.
        * @return zeta(n)-1.
        * @since 2009-08-20
        */
        static public double zeta1(final int n)
        {
                /* precomputed static table in double precision
                */
<span class="nc" id="L2125">                final double[] zmin1 = {0.,0.,</span>
6.449340668482264364724151666e-01,
2.020569031595942853997381615e-01,8.232323371113819151600369654e-02,
3.692775514336992633136548646e-02,1.734306198444913971451792979e-02,
8.349277381922826839797549850e-03,4.077356197944339378685238509e-03,
2.008392826082214417852769232e-03,9.945751278180853371459589003e-04,
4.941886041194645587022825265e-04,2.460865533080482986379980477e-04,
1.227133475784891467518365264e-04,6.124813505870482925854510514e-05,
3.058823630702049355172851064e-05,1.528225940865187173257148764e-05,
7.637197637899762273600293563e-06,3.817293264999839856461644622e-06,
1.908212716553938925656957795e-06,9.539620338727961131520386834e-07,
4.769329867878064631167196044e-07,2.384505027277329900036481868e-07,
1.192199259653110730677887189e-07,5.960818905125947961244020794e-08,
2.980350351465228018606370507e-08,1.490155482836504123465850663e-08,
7.450711789835429491981004171e-09,3.725334024788457054819204018e-09,
1.862659723513049006403909945e-09,9.313274324196681828717647350e-10,
4.656629065033784072989233251e-10,2.328311833676505492001455976e-10,
1.164155017270051977592973835e-10,5.820772087902700889243685989e-11,
2.910385044497099686929425228e-11,1.455192189104198423592963225e-11,
7.275959835057481014520869012e-12,3.637979547378651190237236356e-12,
1.818989650307065947584832101e-12,9.094947840263889282533118387e-13,
4.547473783042154026799112029e-13,2.273736845824652515226821578e-13,
1.136868407680227849349104838e-13,5.684341987627585609277182968e-14,
2.842170976889301855455073705e-14,1.421085482803160676983430714e-14,
7.105427395210852712877354480e-15,3.552713691337113673298469534e-15,
1.776356843579120327473349014e-15,8.881784210930815903096091386e-16,
4.440892103143813364197770940e-16,2.220446050798041983999320094e-16,
1.110223025141066133720544570e-16,5.551115124845481243723736590e-17,
2.775557562136124172581632454e-17,1.387778780972523276283909491e-17,
6.938893904544153697446085326e-18,3.469446952165922624744271496e-18,
1.734723476047576572048972970e-18,8.673617380119933728342055067e-19,
4.336808690020650487497023566e-19,2.168404344997219785013910168e-19,
1.084202172494241406301271117e-19,5.421010862456645410918700404e-20,
2.710505431223468831954621312e-20,1.355252715610116458148523400e-20,
6.776263578045189097995298742e-21,3.388131789020796818085703100e-21,
1.694065894509799165406492747e-21,8.470329472546998348246992609e-22,
4.235164736272833347862270483e-22,2.117582368136194731844209440e-22,
1.058791184068023385226500154e-22,5.293955920339870323813912303e-23,
2.646977960169852961134116684e-23,1.323488980084899080309451025e-23,
6.617444900424404067355245332e-24,3.308722450212171588946956384e-24,
1.654361225106075646229923677e-24,8.271806125530344403671105617e-25,
4.135903062765160926009382456e-25,2.067951531382576704395967919e-25,
1.033975765691287099328409559e-25,5.169878828456431320410133217e-26,
2.584939414228214268127761771e-26,1.292469707114106670038112612e-26,
6.462348535570531803438002161e-27,3.231174267785265386134814118e-27,
1.615587133892632521206011406e-27,8.077935669463162033158738186e-28,
4.038967834731580825622262813e-28,2.019483917365790349158762647e-28,
1.009741958682895153361925070e-28,5.048709793414475696084771173e-29,
2.524354896707237824467434194e-29,1.262177448353618904375399966e-29,
6.310887241768094495682609390e-30,3.155443620884047239109841220e-30,
1.577721810442023616644432780e-30,7.888609052210118073520537800e-31
                } ;
<span class="nc bnc" id="L2177" title="All 2 branches missed.">                if( n &lt;= 0 )</span>
<span class="nc" id="L2178">                        throw new ProviderException(&quot;Not implemented: zeta at negative argument &quot;+n) ;</span>
<span class="nc bnc" id="L2179" title="All 2 branches missed.">                if( n == 1 )</span>
<span class="nc" id="L2180">                        throw new ArithmeticException(&quot;Pole at zeta(1) &quot;) ;</span>

<span class="nc bnc" id="L2182" title="All 2 branches missed.">                if( n &lt; zmin1.length )</span>
                        /* look it up if available */
<span class="nc" id="L2184">                        return zmin1[n] ;</span>
                else
                {
                        /* Result is roughly 2^(-n), desired accuracy 18 digits. If zeta(n) is computed, the equivalent accuracy
                        * in relative units is higher, because zeta is around 1.
                        */
<span class="nc" id="L2190">                        double eps = 1.e-18*Math.pow(2.,(double)(-n) ) ;</span>
<span class="nc" id="L2191">                        MathContext mc = new MathContext( err2prec(eps) ) ;</span>
<span class="nc" id="L2192">                        return zeta(n,mc).subtract(BigDecimal.ONE).doubleValue() ;</span>
                }
        } /* zeta */


        /** trigonometric cot.
        * @param x The argument.
        * @return cot(x) = 1/tan(x).
        */
        static public double cot(final double x)
        {
<span class="nc" id="L2203">                return 1./Math.tan(x) ;</span>
        }

        /** Digamma function.
        * @param x The main argument.
        * @return psi(x).
        *  The error is sometimes up to 10 ulp, where AS 6.3.15 suffers from cancellation of digits and psi=0
        * @since 2009-08-26
        */
        static public double psi(final double x)
        {
                /* the single positive zero of psi(x)
                */
<span class="nc" id="L2216">                final double psi0 = 1.46163214496836234126265954232572132846819;</span>
<span class="nc bnc" id="L2217" title="All 2 branches missed.">                if ( x &gt; 2.0)</span>
                {
                        /* Reduce to a value near x=1 with the standard recurrence formula.
                        * Abramowitz-Stegun 6.3.5
                        */
<span class="nc" id="L2222">                        int m = (int) ( x-0.5 );</span>
<span class="nc" id="L2223">                        double xmin1 = x-m ;</span>
<span class="nc" id="L2224">                        double resul = 0. ;</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">                        for(int i=1; i &lt;= m ; i++)</span>
<span class="nc" id="L2226">                                resul += 1./(x-i) ;</span>
<span class="nc" id="L2227">                        return resul+psi(xmin1) ;</span>
                }
<span class="nc bnc" id="L2229" title="All 2 branches missed.">                else if ( Math.abs(x-psi0) &lt; 0.55)</span>
                {
                        /* Taylor approximation around the local zero
                        */
<span class="nc" id="L2233">                        final double [] psiT0 = { 9.67672245447621170427e-01, -4.42763168983592106093e-01,</span>
                        2.58499760955651010624e-01, -1.63942705442406527504e-01, 1.07824050691262365757e-01,
                        -7.21995612564547109261e-02, 4.88042881641431072251e-02, -3.31611264748473592923e-02,
                        2.25976482322181046596e-02, -1.54247659049489591388e-02, 1.05387916166121753881e-02,
                        -7.20453438635686824097e-03, 4.92678139572985344635e-03, -3.36980165543932808279e-03,
                        2.30512632673492783694e-03, -1.57693677143019725927e-03, 1.07882520191629658069e-03,
                        -7.38070938996005129566e-04, 5.04953265834602035177e-04, -3.45468025106307699556e-04,
                        2.36356015640270527924e-04, -1.61706220919748034494e-04, 1.10633727687474109041e-04,
                        -7.56917958219506591924e-05, 5.17857579522208086899e-05, -3.54300709476596063157e-05,
                        2.42400661186013176527e-05, -1.65842422718541333752e-05, 1.13463845846638498067e-05,
                        -7.76281766846209442527e-06, 5.31106092088986338732e-06, -3.63365078980104566837e-06,
                        2.48602273312953794890e-06, -1.70085388543326065825e-06, 1.16366753635488427029e-06,
                        -7.96142543124197040035e-07, 5.44694193066944527850e-07, -3.72661612834382295890e-07,
                        2.54962655202155425666e-07, -1.74436951177277452181e-07, 1.19343948298302427790e-07,
                        -8.16511518948840884084e-08, 5.58629968353217144428e-08, -3.82196006191749421243e-08,
                        2.61485769519618662795e-08, -1.78899848649114926515e-08, 1.22397314032336619391e-08,
                        -8.37401629767179054290e-09, 5.72922285984999377160e-09} ;
<span class="nc" id="L2250">                        final double xdiff = x-psi0 ;</span>
<span class="nc" id="L2251">                        double resul = 0. ;</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">                        for( int i = psiT0.length-1; i &gt;=0 ; i--)</span>
<span class="nc" id="L2253">                                resul = resul*xdiff+psiT0[i] ;</span>
<span class="nc" id="L2254">                        return resul*xdiff ;</span>
                }
<span class="nc bnc" id="L2256" title="All 2 branches missed.">                else if ( x &lt; 0. )</span>
                {
                        /* Reflection formula */
<span class="nc" id="L2259">                        double xmin = 1.-x ;</span>
<span class="nc" id="L2260">                        return psi(xmin) + Math.PI/Math.tan(Math.PI*xmin) ;</span>
                }
                else
                {
<span class="nc" id="L2264">                        double xmin1 = x-1 ;</span>
<span class="nc" id="L2265">                        double resul = 0. ;</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">                        for(int k=26 ; k&gt;= 1; k--)</span>
                        {
<span class="nc" id="L2268">                                resul -= zeta1(2*k+1) ;</span>
<span class="nc" id="L2269">                                resul *= xmin1*xmin1 ;</span>
                        }
                                /* 0.422... = 1 -gamma */
<span class="nc" id="L2272">                        return resul + 0.422784335098467139393487909917597568 </span>
<span class="nc" id="L2273">                                + 0.5/xmin1-1./(1-xmin1*xmin1)- Math.PI/( 2.*Math.tan(Math.PI*xmin1) );</span>
                }
        } /* psi */


        /** Broadhurst ladder sequence.
        * @param a The vector of 8 integer arguments
        * @param mc Specification of the accuracy of the result
        * @return S_(n,p)(a)
        * @since 2009-08-09
        * @see &lt;a href=&quot;http://arxiv.org/abs/math/9803067&quot;&gt;arXiv:math/9803067&lt;/a&gt;
        */
        static protected BigDecimal broadhurstBBP(final int n, final int p, final int a[], MathContext mc)
        {
                /* Explore the actual magnitude of the result first with a quick estimate.
                */
<span class="nc" id="L2289">                double x = 0.0 ;</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">                for(int k=1; k &lt; 10 ; k++)</span>
<span class="nc" id="L2291">                        x += a[ (k-1) % 8]/Math.pow(2., p*(k+1)/2)/Math.pow((double)k,n) ;</span>

                /* Convert the relative precision and estimate of the result into an absolute precision.
                */
<span class="nc" id="L2295">                double eps = prec2err(x,mc.getPrecision()) ;</span>

                /* Divide this through the number of terms in the sum to account for error accumulation
                * The divisor 2^(p(k+1)/2) means that on the average each 8th term in k has shrunk by
                * relative to the 8th predecessor by 1/2^(4p).  1/2^(4pc) = 10^(-precision) with c the 8term
                * cycles yields c=log_2( 10^precision)/4p = 3.3*precision/4p  with k=8c
                */
<span class="nc" id="L2302">                int kmax= (int)(6.6*mc.getPrecision()/p) ;</span>

                /* Now eps is the absolute error in each term */
<span class="nc" id="L2305">                eps /= kmax ;</span>
<span class="nc" id="L2306">                BigDecimal res = BigDecimal.ZERO ;</span>
<span class="nc" id="L2307">                for(int c =0 ; ; c++)</span>
                {
<span class="nc" id="L2309">                        Rational r = new Rational() ;</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">                        for (int k=0; k &lt; 8 ; k++)</span>
                        {
<span class="nc" id="L2312">                                Rational tmp = new Rational(new BigInteger(&quot;&quot;+a[k]),(new BigInteger(&quot;&quot;+(1+8*c+k))).pow(n)) ;</span>
                                /* floor( (pk+p)/2)
                                */
<span class="nc" id="L2315">                                int pk1h = p*(2+8*c+k)/2 ;</span>
<span class="nc" id="L2316">                                tmp = tmp.divide( BigInteger.ONE.shiftLeft(pk1h) ) ;</span>
<span class="nc" id="L2317">                                r = r.add(tmp) ;</span>
                        }
        
<span class="nc bnc" id="L2320" title="All 2 branches missed.">                        if ( Math.abs(r.doubleValue()) &lt; eps)</span>
<span class="nc" id="L2321">                                break;</span>
<span class="nc" id="L2322">                        MathContext mcloc = new MathContext( 1+err2prec(r.doubleValue(),eps) ) ;</span>
<span class="nc" id="L2323">                        res = res.add( r.BigDecimalValue(mcloc) ) ;</span>
                }
<span class="nc" id="L2325">                return res.round(mc) ;</span>
        } /* broadhurstBBP */








        /** Add a BigDecimal and a BigInteger.
        * @param x The left summand
        * @param y The right summand
        * @return The sum x+y.
        * @since 2012-03-02
        */
        static public BigDecimal add(final BigDecimal x, final BigInteger y)
        {
<span class="nc" id="L2343">                return x.add(new BigDecimal(y)) ;</span>
        } /* add */


        /** Add and round according to the larger of the two ulp's.
        * @param x The left summand
        * @param y The right summand
        * @return The sum x+y.
        * @since 2009-07-30
        */
        static public BigDecimal addRound(final BigDecimal x, final BigDecimal y)
        {
<span class="nc" id="L2355">                BigDecimal resul = x.add(y) ;</span>
                /* The estimation of the absolute error in the result is |err(y)|+|err(x)| 
                */
<span class="nc" id="L2358">                double errR = Math.abs( y.ulp().doubleValue()/2. ) + Math.abs( x.ulp().doubleValue()/2. ) ;</span>
<span class="nc" id="L2359">                MathContext mc = new MathContext( err2prec(resul.doubleValue(),errR) ) ;</span>
<span class="nc" id="L2360">                return resul.round(mc) ;</span>
        } /* addRound */

        /** Add and round according to the larger of the two ulp's.
        * @param x The left summand
        * @param y The right summand
        * @return The sum x+y.
        * @since 2010-07-19
        */
        static public BigComplex addRound(final BigComplex x, final BigDecimal y)
        {
<span class="nc" id="L2371">                final BigDecimal R = addRound(x.re,y) ;</span>
<span class="nc" id="L2372">                return new BigComplex(R,x.im) ;</span>
        } /* addRound */

        /** Add and round according to the larger of the two ulp's.
        * @param x The left summand
        * @param y The right summand
        * @return The sum x+y.
        * @since 2010-07-19
        */
        static public BigComplex addRound(final BigComplex x, final BigComplex y)
        {
<span class="nc" id="L2383">                final BigDecimal R = addRound(x.re,y.re) ;</span>
<span class="nc" id="L2384">                final BigDecimal I = addRound(x.im,y.im) ;</span>
<span class="nc" id="L2385">                return new BigComplex(R,I) ;</span>
        } /* addRound */

        /** Subtract and round according to the larger of the two ulp's.
        * @param x The left term.
        * @param y The right term.
        * @return The difference x-y.
        * @since 2009-07-30
        */
        static public BigDecimal subtractRound(final BigDecimal x, final BigDecimal y)
        {
<span class="nc" id="L2396">                BigDecimal resul = x.subtract(y) ;</span>
                /* The estimation of the absolute error in the result is |err(y)|+|err(x)| 
                */
<span class="nc" id="L2399">                double errR = Math.abs( y.ulp().doubleValue()/2. ) + Math.abs( x.ulp().doubleValue()/2. ) ;</span>
<span class="nc" id="L2400">                MathContext mc = new MathContext( err2prec(resul.doubleValue(),errR) ) ;</span>
<span class="nc" id="L2401">                return resul.round(mc) ;</span>
        } /* subtractRound */

        /** Subtract and round according to the larger of the two ulp's.
        * @param x The left summand
        * @param y The right summand
        * @return The difference x-y.
        * @since 2010-07-19
        */
        static public BigComplex subtractRound(final BigComplex x, final BigComplex y)
        {
<span class="nc" id="L2412">                final BigDecimal R = subtractRound(x.re,y.re) ;</span>
<span class="nc" id="L2413">                final BigDecimal I = subtractRound(x.im,y.im) ;</span>
<span class="nc" id="L2414">                return new BigComplex(R,I) ;</span>
        } /* subtractRound */

        /** Multiply and round.
        * @param x The left factor.
        * @param y The right factor.
        * @return The product x*y.
        * @since 2009-07-30
        */
        static public BigDecimal multiplyRound(final BigDecimal x, final BigDecimal y)
        {
<span class="nc" id="L2425">                BigDecimal resul = x.multiply(y) ;</span>
                /* The estimation of the relative error in the result is the sum of the relative
                * errors |err(y)/y|+|err(x)/x| 
                */
<span class="nc" id="L2429">                MathContext mc = new MathContext( Math.min(x.precision(),y.precision()) ) ;</span>
<span class="nc" id="L2430">                return resul.round(mc) ;</span>
        } /* multiplyRound */

        /** Multiply and round.
        * @param x The left factor.
        * @param y The right factor.
        * @return The product x*y.
        * @since 2010-07-19
        */
        static public BigComplex multiplyRound(final BigComplex x, final BigDecimal y)
        {
<span class="nc" id="L2441">                BigDecimal R = multiplyRound(x.re,y) ;</span>
<span class="nc" id="L2442">                BigDecimal I = multiplyRound(x.im,y) ;</span>
<span class="nc" id="L2443">                return new BigComplex(R,I) ;</span>
        } /* multiplyRound */

        /** Multiply and round.
        * @param x The left factor.
        * @param y The right factor.
        * @return The product x*y.
        * @since 2010-07-19
        */
        static public BigComplex multiplyRound(final BigComplex x, final BigComplex y)
        {
<span class="nc" id="L2454">                BigDecimal R = subtractRound(multiplyRound(x.re,y.re), multiplyRound(x.im,y.im)) ;</span>
<span class="nc" id="L2455">                BigDecimal I = addRound(multiplyRound(x.re,y.im), multiplyRound(x.im,y.re)) ;</span>
<span class="nc" id="L2456">                return new BigComplex(R,I) ;</span>
        } /* multiplyRound */

        /** Multiply and round.
        * @param x The left factor.
        * @param f The right factor.
        * @return The product x*f.
        * @since 2009-07-30
        */
        static public BigDecimal multiplyRound(final BigDecimal x, final Rational f)
        {
<span class="nc bnc" id="L2467" title="All 2 branches missed.">                if (  f.compareTo(BigInteger.ZERO) == 0 ) </span>
<span class="nc" id="L2468">                        return BigDecimal.ZERO ;</span>
                else
                {
                        /* Convert the rational value with two digits of extra precision
                        */
<span class="nc" id="L2473">                        MathContext mc = new MathContext( 2+x.precision() ) ;</span>
<span class="nc" id="L2474">                        BigDecimal fbd = f.BigDecimalValue(mc) ;</span>

                        /* and the precision of the product is then dominated by the precision in x
                        */
<span class="nc" id="L2478">                        return multiplyRound(x,fbd) ;</span>
                }
        }

        /** Multiply and round.
        * @param x The left factor.
        * @param n The right factor.
        * @return The product x*n.
        * @since 2009-07-30
        */
        static public BigDecimal multiplyRound(final BigDecimal x, final int n)
        {
<span class="nc" id="L2490">                BigDecimal resul = x.multiply(new BigDecimal(n)) ;</span>
                /* The estimation of the absolute error in the result is |n*err(x)|
                */
<span class="nc bnc" id="L2493" title="All 2 branches missed.">                MathContext mc = new MathContext( n != 0 ? x.precision(): 0 ) ;</span>
<span class="nc" id="L2494">                return resul.round(mc) ;</span>
        }

        /** Multiply and round.
        * @param x The left factor.
        * @param n The right factor.
        * @return the product x*n
        * @since 2009-07-30
        */
        static public BigDecimal multiplyRound(final BigDecimal x, final BigInteger n)
        {
<span class="nc" id="L2505">                BigDecimal resul = x.multiply(new BigDecimal(n)) ;</span>
                /* The estimation of the absolute error in the result is |n*err(x)|
                */
<span class="nc bnc" id="L2508" title="All 2 branches missed.">                MathContext mc = new MathContext( n.compareTo(BigInteger.ZERO) != 0 ? x.precision(): 0 ) ;</span>
<span class="nc" id="L2509">                return resul.round(mc) ;</span>
        }

        /** Divide and round.
        * @param x The numerator
        * @param y The denominator
        * @return the divided x/y
        * @since 2009-07-30
        */
        static public BigDecimal divideRound(final BigDecimal x, final BigDecimal y)
        {
                /* The estimation of the relative error in the result is |err(y)/y|+|err(x)/x| 
                */
<span class="nc" id="L2522">                MathContext mc = new MathContext( Math.min(x.precision(),y.precision()) ) ;</span>
<span class="nc" id="L2523">                BigDecimal resul = x.divide(y,mc) ;</span>
                /* If x and y are precise integer values that may have common factors,
                * the method above will truncate trailing zeros, which may result in
                * a smaller apparent accuracy than starte... add missing trailing zeros now.
                */
<span class="nc" id="L2528">                return scalePrec(resul,mc) ;</span>
        }

        /** Build the inverse and maintain the approximate accuracy.
        * @param z The denominator
        * @return The divided 1/z = [Re(z)-i*Im(z)]/ [Re^2 z + Im^2 z]
        * @since 2010-07-19
        */
        static public BigComplex invertRound(final BigComplex z)
        {
<span class="nc bnc" id="L2538" title="All 2 branches missed.">                if (z.im.compareTo(BigDecimal.ZERO) == 0)</span>
                {
                        /* In this case with vanishing Im(x), the result is  simply 1/Re z.
                        */
<span class="nc" id="L2542">                        final MathContext mc = new MathContext( z.re.precision() ) ;</span>
<span class="nc" id="L2543">                        return new BigComplex( BigDecimal.ONE.divide( z.re, mc) ) ;</span>
                }
<span class="nc bnc" id="L2545" title="All 2 branches missed.">                else if (z.re.compareTo(BigDecimal.ZERO) == 0)</span>
                {
                        /* In this case with vanishing Re(z), the result is  simply -i/Im z
                        */
<span class="nc" id="L2549">                        final MathContext mc = new MathContext( z.im.precision() ) ;</span>
<span class="nc" id="L2550">                        return new BigComplex(BigDecimal.ZERO, BigDecimal.ONE.divide( z.im, mc).negate() ) ;</span>
                }
                else 
                {
                        /* 1/(x.re+I*x.im) = 1/(x.re+x.im^2/x.re) - I /(x.im +x.re^2/x.im)
                        */
<span class="nc" id="L2556">                        BigDecimal R  = addRound(z.re, divideRound(multiplyRound(z.im,z.im), z.re) ) ;</span>
<span class="nc" id="L2557">                        BigDecimal I  = addRound(z.im, divideRound(multiplyRound(z.re,z.re), z.im) ) ;</span>
<span class="nc" id="L2558">                        MathContext mc = new MathContext( 1+R.precision() ) ;</span>
<span class="nc" id="L2559">                        R = BigDecimal.ONE.divide(R,mc) ;</span>
<span class="nc" id="L2560">                        mc = new MathContext( 1+I.precision() ) ;</span>
<span class="nc" id="L2561">                        I = BigDecimal.ONE.divide(I,mc) ;</span>
<span class="nc" id="L2562">                        return new BigComplex(R,I.negate()) ;</span>
                }
        }

        /** Divide and round.
        * @param x The numerator
        * @param y The denominator
        * @return the divided x/y
        * @since 2010-07-19
        */
        static public BigComplex divideRound(final BigComplex x, final BigComplex y)
        {
<span class="nc" id="L2574">                return multiplyRound( x, invertRound(y) ) ;</span>
        }

        /** Divide and round.
        * @param x The numerator
        * @param n The denominator
        * @return the divided x/n
        * @since 2009-07-30
        */
        static public BigDecimal divideRound(final BigDecimal x, final int n)
        {
                /* The estimation of the relative error in the result is |err(x)/x| 
                */
<span class="nc" id="L2587">                MathContext mc = new MathContext( x.precision() ) ;</span>
<span class="nc" id="L2588">                return x.divide(new BigDecimal(n),mc) ;</span>
        }

        /** Divide and round.
        * @param x The numerator
        * @param n The denominator
        * @return the divided x/n
        * @since 2009-07-30
        */
        static public BigDecimal divideRound(final BigDecimal x, final BigInteger n)
        {
                /* The estimation of the relative error in the result is |err(x)/x| 
                */
<span class="nc" id="L2601">                MathContext mc = new MathContext( x.precision() ) ;</span>
<span class="nc" id="L2602">                return x.divide(new BigDecimal(n),mc) ;</span>
        } /* divideRound */

        /** Divide and round.
        * @param n The numerator
        * @param x The denominator
        * @return the divided n/x
        * @since 2009-08-05
        */
        static public BigDecimal divideRound(final BigInteger n, final BigDecimal x)
        {
                /* The estimation of the relative error in the result is |err(x)/x| 
                */
<span class="nc" id="L2615">                MathContext mc = new MathContext( x.precision() ) ;</span>
<span class="nc" id="L2616">                return new BigDecimal(n).divide(x,mc) ;</span>
        } /* divideRound */

        /** Divide and round.
        * @param n The numerator
        * @param x The denominator
        * @return the divided n/x
        * @since 2012-03-01
        */
        static public BigComplex divideRound(final BigInteger n, final BigComplex x)
        {
                /* catch case of real-valued denominator first
                */
<span class="nc bnc" id="L2629" title="All 2 branches missed.">                if ( x.im.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L2630">                        return new BigComplex( divideRound(n,x.re),BigDecimal.ZERO ) ;</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">                else if ( x.re.compareTo(BigDecimal.ZERO) == 0 )</span>
<span class="nc" id="L2632">                        return new BigComplex( BigDecimal.ZERO, divideRound(n,x.im).negate() ) ;</span>
                        
<span class="nc" id="L2634">                BigComplex z = invertRound(x) ;</span>
                /* n/(x+iy) = nx/(x^2+y^2) -nyi/(x^2+y^2)       
                */
<span class="nc" id="L2637">                BigDecimal repart = multiplyRound(z.re, n) ;</span>
<span class="nc" id="L2638">                BigDecimal impart = multiplyRound(z.im, n) ;</span>
<span class="nc" id="L2639">                return new BigComplex( repart, impart) ;</span>
        } /* divideRound */

        /** Divide and round.
        * @param n The numerator.
        * @param x The denominator.
        * @return the divided n/x.
        * @since 2009-08-05
        */
        static public BigDecimal divideRound(final int n, final BigDecimal x)
        {
                /* The estimation of the relative error in the result is |err(x)/x| 
                */
<span class="nc" id="L2652">                MathContext mc = new MathContext( x.precision() ) ;</span>
<span class="nc" id="L2653">                return new BigDecimal(n).divide(x,mc) ;</span>
        }

        /** Append decimal zeros to the value. This returns a value which appears to have
        * a higher precision than the input.
        * @param x The input value
        * @param d The (positive) value of zeros to be added as least significant digits.
        * @return The same value as the input but with increased (pseudo) precision.
        */
        static public BigDecimal scalePrec(final BigDecimal x, int d)
        {
<span class="nc" id="L2664">                return x.setScale(d+x.scale()) ;</span>
        }

        /** Append decimal zeros to the value. This returns a value which appears to have
        * a higher precision than the input.
        * @param x The input value
        * @param d The (positive) value of zeros to be added as least significant digits.
        * @return The same value as the input but with increased (pseudo) precision.
        */
        static public BigComplex scalePrec(final BigComplex x, int d)
        {
<span class="nc" id="L2675">                return new BigComplex( scalePrec(x.re,d),scalePrec(x.im,d)) ;</span>
        }

        /** Boost the precision by appending decimal zeros to the value. This returns a value which appears to have
        * a higher precision than the input.
        * @param x The input value
        * @param mc The requirement on the minimum precision on return.
        * @return The same value as the input but with increased (pseudo) precision.
        */
        static public BigDecimal scalePrec(final BigDecimal x, final MathContext mc)
        {
<span class="nc" id="L2686">                final int diffPr = mc.getPrecision() - x.precision() ;</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">                if ( diffPr &gt; 0 )</span>
<span class="nc" id="L2688">                        return scalePrec(x, diffPr) ;</span>
                else
<span class="nc" id="L2690">                        return x ;</span>
        } /* BigDecimalMath.scalePrec */

        /** Convert an absolute error to a precision.
        * @param x The value of the variable
        * @param xerr The absolute error in the variable
        * @return The number of valid digits in x.
        *    The value is rounded down, and on the pessimistic side for that reason.
        * @since 2009-06-25
        */
        static public int err2prec(BigDecimal x, BigDecimal xerr)
        {
<span class="nc" id="L2702">                return err2prec( xerr.divide(x,MathContext.DECIMAL64).doubleValue() );</span>
        }

        /** Convert an absolute error to a precision.
        * @param x The value of the variable
        *    The value returned depends only on the absolute value, not on the sign.
        * @param xerr The absolute error in the variable
        *    The value returned depends only on the absolute value, not on the sign.
        * @return The number of valid digits in x.
        *    Derived from the representation x+- xerr, as if the error was represented
        *    in a &quot;half width&quot; (half of the error bar) form.
        *    The value is rounded down, and on the pessimistic side for that reason.
        * @since 2009-05-30
        */
        static public int err2prec(double x, double xerr)
        {
                /* Example: an error of xerr=+-0.5 at x=100 represents 100+-0.5 with
                * a precision = 3 (digits).
                */
<span class="nc" id="L2721">                return 1+(int)(Math.log10(Math.abs(0.5*x/xerr) ) );</span>
        }

        /** Convert a relative error to a precision.
        * @param xerr The relative error in the variable.
        *    The value returned depends only on the absolute value, not on the sign.
        * @return The number of valid digits in x.
        *    The value is rounded down, and on the pessimistic side for that reason.
        * @since 2009-08-05
        */
        static public int err2prec(double xerr)
        {
                /* Example: an error of xerr=+-0.5 a precision of 1 (digit), an error of
                * +-0.05 a precision of 2 (digits)
                */
<span class="nc" id="L2736">                return 1+(int)(Math.log10(Math.abs(0.5/xerr) ) );</span>
        }

        /** Convert a precision (relative error) to an absolute error.
        *    The is the inverse functionality of err2prec().
        * @param x The value of the variable
        *    The value returned depends only on the absolute value, not on the sign.
        * @param prec The number of valid digits of the variable.
        * @return the absolute error in x.
        *    Derived from the an accuracy of one half of the ulp.
        * @since 2009-08-09
        */
        static public double prec2err(final double x, final int prec)
        {
<span class="nc" id="L2750">                return 5.*Math.abs(x)*Math.pow(10.,-prec) ;</span>
        }

} /* BigDecimalMath */
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>